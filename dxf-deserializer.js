!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.deserialize=e():t.deserialize=e()}("undefined"!=typeof self?self:this,(function(){return function(t){var e={};function n(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:o})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)n.d(o,r,function(e){return t[e]}.bind(null,r));return o},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=34)}([function(t,e){const n=5e-6*1e-5*Math.sin(.1);let o=1;t.exports={_CSGDEBUG:!1,defaultResolution2D:32,defaultResolution3D:12,EPS:1e-5,angleEPS:.1,areaEPS:n,all:0,top:1,bottom:2,left:3,right:4,front:5,back:6,staticTag:o,getTag:()=>o++}},function(t,e,n){const{IsFloat:o}=n(6),r=n(2),s=function(t,e,n){if(3===arguments.length)this._x=parseFloat(t),this._y=parseFloat(e),this._z=parseFloat(n);else if(2===arguments.length)this._x=parseFloat(t),this._y=parseFloat(e),this._z=0;else{var i=!0;if(1===arguments.length)if("object"==typeof t)t instanceof s?(this._x=t._x,this._y=t._y,this._z=t._z):t instanceof r?(this._x=t._x,this._y=t._y,this._z=0):t instanceof Array?t.length<2||t.length>3?i=!1:(this._x=parseFloat(t[0]),this._y=parseFloat(t[1]),3===t.length?this._z=parseFloat(t[2]):this._z=0):"x"in t&&"y"in t?(this._x=parseFloat(t.x),this._y=parseFloat(t.y),this._z="z"in t?parseFloat(t.z):0):"_x"in t&&"_y"in t?(this._x=parseFloat(t._x),this._y=parseFloat(t._y),this._z="_z"in t?parseFloat(t._z):0):i=!1;else{var l=parseFloat(t);this._x=l,this._y=l,this._z=l}else i=!1;if(!i)throw new Error("wrong arguments");o(this._x)&&o(this._y)&&o(this._z)||(i=!1)}};s.Create=function(t,e,n){var o=Object.create(s.prototype);return o._x=t,o._y=e,o._z=n,o},s.prototype={get x(){return this._x},get y(){return this._y},get z(){return this._z},set x(t){throw new Error("Vector3D is immutable")},set y(t){throw new Error("Vector3D is immutable")},set z(t){throw new Error("Vector3D is immutable")},clone:function(){return s.Create(this._x,this._y,this._z)},negated:function(){return s.Create(-this._x,-this._y,-this._z)},abs:function(){return s.Create(Math.abs(this._x),Math.abs(this._y),Math.abs(this._z))},plus:function(t){return s.Create(this._x+t._x,this._y+t._y,this._z+t._z)},minus:function(t){return s.Create(this._x-t._x,this._y-t._y,this._z-t._z)},times:function(t){return s.Create(this._x*t,this._y*t,this._z*t)},dividedBy:function(t){return s.Create(this._x/t,this._y/t,this._z/t)},dot:function(t){return this._x*t._x+this._y*t._y+this._z*t._z},lerp:function(t,e){return this.plus(t.minus(this).times(e))},lengthSquared:function(){return this.dot(this)},length:function(){return Math.sqrt(this.lengthSquared())},unit:function(){return this.dividedBy(this.length())},cross:function(t){return s.Create(this._y*t._z-this._z*t._y,this._z*t._x-this._x*t._z,this._x*t._y-this._y*t._x)},distanceTo:function(t){return this.minus(t).length()},distanceToSquared:function(t){return this.minus(t).lengthSquared()},equals:function(t){return this._x===t._x&&this._y===t._y&&this._z===t._z},multiply4x4:function(t){return t.leftMultiply1x3Vector(this)},transform:function(t){return t.leftMultiply1x3Vector(this)},toString:function(){return"("+this._x.toFixed(5)+", "+this._y.toFixed(5)+", "+this._z.toFixed(5)+")"},randomNonParallelVector:function(){var t=this.abs();return t._x<=t._y&&t._x<=t._z?s.Create(1,0,0):t._y<=t._x&&t._y<=t._z?s.Create(0,1,0):s.Create(0,0,1)},min:function(t){return s.Create(Math.min(this._x,t._x),Math.min(this._y,t._y),Math.min(this._z,t._z))},max:function(t){return s.Create(Math.max(this._x,t._x),Math.max(this._y,t._y),Math.max(this._z,t._z))}},t.exports=s},function(t,e,n){const{IsFloat:o}=n(6),r=function(t,e){if(2===arguments.length)this._x=parseFloat(t),this._y=parseFloat(e);else{var n=!0;if(1===arguments.length)if("object"==typeof t)t instanceof r?(this._x=t._x,this._y=t._y):t instanceof Array?(this._x=parseFloat(t[0]),this._y=parseFloat(t[1])):"x"in t&&"y"in t?(this._x=parseFloat(t.x),this._y=parseFloat(t.y)):n=!1;else{var s=parseFloat(t);this._x=s,this._y=s}else n=!1;if(n&&(o(this._x)&&o(this._y)||(n=!1)),!n)throw new Error("wrong arguments")}};r.fromAngle=function(t){return r.fromAngleRadians(t)},r.fromAngleDegrees=function(t){var e=Math.PI*t/180;return r.fromAngleRadians(e)},r.fromAngleRadians=function(t){return r.Create(Math.cos(t),Math.sin(t))},r.Create=function(t,e){var n=Object.create(r.prototype);return n._x=t,n._y=e,n},r.prototype={get x(){return this._x},get y(){return this._y},set x(t){throw new Error("Vector2D is immutable")},set y(t){throw new Error("Vector2D is immutable")},toVector3D:function(t){return new(n(1))(this._x,this._y,t)},equals:function(t){return this._x===t._x&&this._y===t._y},clone:function(){return r.Create(this._x,this._y)},negated:function(){return r.Create(-this._x,-this._y)},plus:function(t){return r.Create(this._x+t._x,this._y+t._y)},minus:function(t){return r.Create(this._x-t._x,this._y-t._y)},times:function(t){return r.Create(this._x*t,this._y*t)},dividedBy:function(t){return r.Create(this._x/t,this._y/t)},dot:function(t){return this._x*t._x+this._y*t._y},lerp:function(t,e){return this.plus(t.minus(this).times(e))},length:function(){return Math.sqrt(this.dot(this))},distanceTo:function(t){return this.minus(t).length()},distanceToSquared:function(t){return this.minus(t).lengthSquared()},lengthSquared:function(){return this.dot(this)},unit:function(){return this.dividedBy(this.length())},cross:function(t){return this._x*t._y-this._y*t._x},normal:function(){return r.Create(this._y,-this._x)},multiply4x4:function(t){return t.leftMultiply1x2Vector(this)},transform:function(t){return t.leftMultiply1x2Vector(this)},angle:function(){return this.angleRadians()},angleDegrees:function(){return 180*this.angleRadians()/Math.PI},angleRadians:function(){return Math.atan2(this._y,this._x)},min:function(t){return r.Create(Math.min(this._x,t._x),Math.min(this._y,t._y))},max:function(t){return r.Create(Math.max(this._x,t._x),Math.max(this._y,t._y))},toString:function(){return"("+this._x.toFixed(5)+", "+this._y.toFixed(5)+")"},abs:function(){return r.Create(Math.abs(this._x),Math.abs(this._y))}},t.exports=r},function(t,e,n){const o=n(1),r=n(5),s=n(10),{_CSGDEBUG:i,EPS:l,getTag:a,areaEPS:u}=n(0);let c=function(t,e,o){if(this.vertices=t,e||(e=c.defaultShared),this.shared=e,arguments.length>=3)this.plane=o;else{const e=n(4);this.plane=e.fromVector3Ds(t[0].pos,t[1].pos,t[2].pos)}if(i&&!this.checkIfConvex())throw new Error("Not convex!")};c.prototype={checkIfConvex:function(){return c.verticesConvex(this.vertices,this.plane.normal)},setColor:function(t){let e=c.Shared.fromColor.apply(this,arguments);return this.shared=e,this},getSignedVolume:function(){let t=0;for(let e=0;e<this.vertices.length-2;e++)t+=this.vertices[0].pos.dot(this.vertices[e+1].pos.cross(this.vertices[e+2].pos));return t/=6,t},getArea:function(){let t=0;for(let e=0;e<this.vertices.length-2;e++)t+=this.vertices[e+1].pos.minus(this.vertices[0].pos).cross(this.vertices[e+2].pos.minus(this.vertices[e+1].pos)).length();return t/=2,t},getTetraFeatures:function(t){let e=[];return t.forEach((function(t){"volume"===t?e.push(this.getSignedVolume()):"area"===t&&e.push(this.getArea())}),this),e},extrude:function(t){const{fromPolygons:e}=n(7);let o=[],r=this;r.plane.normal.dot(t)>0&&(r=r.flipped()),o.push(r);let s=r.translate(t),i=this.vertices.length;for(let t=0;t<i;t++){let e=[],n=t<i-1?t+1:0;e.push(r.vertices[t].pos),e.push(s.vertices[t].pos),e.push(s.vertices[n].pos),e.push(r.vertices[n].pos);let l=c.createFromPoints(e,this.shared);o.push(l)}return s=s.flipped(),o.push(s),e(o)},translate:function(t){return this.transform(s.translation(t))},boundingSphere:function(){if(!this.cachedBoundingSphere){let t=this.boundingBox(),e=t[0].plus(t[1]).times(.5),n=t[1].minus(e).length();this.cachedBoundingSphere=[e,n]}return this.cachedBoundingSphere},boundingBox:function(){if(!this.cachedBoundingBox){let t,e,n=this.vertices,r=n.length;t=0===r?new o(0,0,0):n[0].pos,e=t;for(let o=1;o<r;o++){let r=n[o].pos;t=t.min(r),e=e.max(r)}this.cachedBoundingBox=[t,e]}return this.cachedBoundingBox},flipped:function(){let t=this.vertices.map((function(t){return t.flipped()}));t.reverse();let e=this.plane.flipped();return new c(t,this.shared,e)},transform:function(t){let e=this.vertices.map((function(e){return e.transform(t)})),n=this.plane.transform(t);return t.isMirroring()&&e.reverse(),new c(e,this.shared,n)},toString:function(){let t="Polygon plane: "+this.plane.toString()+"\n";return this.vertices.map((function(e){t+="  "+e.toString()+"\n"})),t},projectToOrthoNormalBasis:function(t){const e=n(8),{fromPointsNoCheck:o}=n(9);let r=o(this.vertices.map((function(e){return t.to2D(e.pos)}))),s=r.area();return Math.abs(s)<u?r=new e:s<0&&(r=r.flipped()),r},solidFromSlices:function(t){return n(47)(this,t)}},c.fromObject=function(t){const e=n(4);let o=t.vertices.map((function(t){return r.fromObject(t)})),s=c.Shared.fromObject(t.shared),i=e.fromObject(t.plane);return new c(o,s,i)},c.createFromPoints=function(t,e,n){let s,i=[];return t.map((function(t){let e=new o(t),n=new r(e);i.push(n)})),s=arguments.length<3?new c(i,e):new c(i,e,n),s},c.verticesConvex=function(t,e){let n=t.length;if(n>2){let o=t[n-2].pos,r=t[n-1].pos;for(let s=0;s<n;s++){let n=t[s].pos;if(!c.isConvexPoint(o,r,n,e))return!1;o=r,r=n}}return!0},c.isConvexPoint=function(t,e,n,o){return e.minus(t).cross(n.minus(e)).dot(o)>=0},c.isStrictlyConvexPoint=function(t,e,n,o){return e.minus(t).cross(n.minus(e)).dot(o)>=l},c.Shared=function(t){if(null!=t&&4!==t.length)throw new Error("Expecting 4 element array");this.color=t},c.Shared.fromObject=function(t){return new c.Shared(t.color)},c.Shared.fromColor=function(t){let e;if(1===arguments.length)e=arguments[0].slice();else{e=[];for(let t=0;t<arguments.length;t++)e.push(arguments[t])}if(3===e.length)e.push(1);else if(4!==e.length)throw new Error("setColor expects either an array with 3 or 4 elements, or 3 or 4 parameters.");return new c.Shared(e)},c.Shared.prototype={getTag:function(){let t=this.tag;return t||(t=a(),this.tag=t),t},getHash:function(){return this.color?this.color.join("/"):"null"}},c.defaultShared=new c.Shared(null),t.exports=c},function(t,e,n){const o=n(1),r=n(16),{EPS:s,getTag:i}=n(0),l=function(t,e){this.normal=t,this.w=e};l.fromObject=function(t){let e=new o(t.normal),n=parseFloat(t.w);return new l(e,n)},l.fromVector3Ds=function(t,e,n){let o=e.minus(t).cross(n.minus(t)).unit();return new l(o,o.dot(t))},l.anyPlaneFromVector3Ds=function(t,e,n){let o=e.minus(t),r=n.minus(t);o.length()<s&&(o=r.randomNonParallelVector()),r.length()<s&&(r=o.randomNonParallelVector());let i=o.cross(r);return i.length()<s&&(r=o.randomNonParallelVector(),i=o.cross(r)),i=i.unit(),new l(i,i.dot(t))},l.fromPoints=function(t,e,n){return t=new o(t),e=new o(e),n=new o(n),l.fromVector3Ds(t,e,n)},l.fromNormalAndPoint=function(t,e){t=new o(t),e=new o(e),t=t.unit();let n=e.dot(t);return new l(t,n)},l.prototype={flipped:function(){return new l(this.normal.negated(),-this.w)},getTag:function(){let t=this.tag;return t||(t=i(),this.tag=t),t},equals:function(t){return this.normal.equals(t.normal)&&this.w===t.w},transform:function(t){let e=t.isMirroring(),n=this.normal.randomNonParallelVector(),o=this.normal.cross(n),r=this.normal.cross(o),s=this.normal.times(this.w),i=s.plus(o),a=s.plus(r);s=s.multiply4x4(t),i=i.multiply4x4(t),a=a.multiply4x4(t);let u=l.fromVector3Ds(s,i,a);return e&&(u=u.flipped()),u},splitLineBetweenPoints:function(t,e){let n=e.minus(t),o=(this.w-this.normal.dot(t))/this.normal.dot(n);return isNaN(o)&&(o=0),o>1&&(o=1),o<0&&(o=0),t.plus(n.times(o))},intersectWithLine:function(t){return t.intersectWithPlane(this)},intersectWithPlane:function(t){return r.fromPlanes(this,t)},signedDistanceToPoint:function(t){return this.normal.dot(t)-this.w},toString:function(){return"[normal: "+this.normal.toString()+", w: "+this.w+"]"},mirrorPoint:function(t){let e=this.signedDistanceToPoint(t);return t.minus(this.normal.times(2*e))}},t.exports=l},function(t,e,n){const o=n(1),{getTag:r}=n(0),s=function(t){this.pos=t};s.fromObject=function(t){var e=new o(t.pos);return new s(e)},s.prototype={flipped:function(){return this},getTag:function(){var t=this.tag;return t||(t=r(),this.tag=t),t},interpolate:function(t,e){var n=this.pos.lerp(t.pos,e);return new s(n)},transform:function(t){var e=this.pos.multiply4x4(t);return new s(e)},toString:function(){return this.pos.toString()}},t.exports=s},function(t,e){t.exports={fnNumberSort:function(t,e){return t-e},fnSortByIndex:function(t,e){return t.index-e.index},IsFloat:function(t){return!isNaN(t)||t===1/0||t===-1/0},solve2Linear:function(t,e,n,o,r,s){let i=1/(t*o-e*n),l=r*o-e*s,a=-r*n+t*s;return l*=i,a*=i,[l,a]},insertSorted:function(t,e,n){let o=0,r=t.length;for(;r>o;){let s=Math.floor((o+r)/2);n(e,t[s])>0?o=s+1:r=s}t.splice(o,0,e)},interpolateBetween2DPointsForY:function(t,e,n){let o,r=n-t.y,s=e.y-t.y;return s<0&&(r=-r,s=-s),o=r<=0?0:r>=s?1:s<1e-10?.5:r/s,t.x+o*(e.x-t.x)},isCAG:function(t){return"sides"in t&&"length"in t.sides},isCSG:function(t){return"polygons"in t&&"length"in t.polygons}}},function(t,e,n){const o=n(1),r=n(5),s=n(4),i=n(24),l=n(3),a=function(t){let e=new(n(12));return e.polygons=t,e.isCanonicalized=!1,e.isRetesselated=!1,e};t.exports={fromPolygons:a,fromSlices:function(t){return i.createFromPoints([[0,0,0],[1,0,0],[1,1,0],[0,1,0]]).solidFromSlices(t)},fromObject:function(t){let e=t.polygons.map((function(t){return l.fromObject(t)})),n=a(e);return n.isCanonicalized=t.isCanonicalized,n.isRetesselated=t.isRetesselated,n},fromCompactBinary:function(t){if("CSG"!==t.class)throw new Error("Not a CSG");let e,n,i,u,c,p,f=[],h=t.planeData,d=h.length/4,m=0;for(let t=0;t<d;t++)e=h[m++],n=h[m++],i=h[m++],u=h[m++],c=o.Create(e,n,i),p=new s(c,u),f.push(p);let g=[];const y=t.vertexData,w=y.length/3;let x,b;m=0;for(let t=0;t<w;t++)e=y[m++],n=y[m++],i=y[m++],x=o.Create(e,n,i),b=new r(x),g.push(b);let v,P,_,C,S=t.shared.map((function(t){return l.Shared.fromObject(t)})),T=[],M=t.numPolygons,z=t.numVerticesPerPolygon,k=t.polygonVertices,E=t.polygonPlaneIndexes,D=t.polygonSharedIndexes;m=0;for(let t=0;t<M;t++){v=z[t],P=[];for(let t=0;t<v;t++)P.push(g[k[m++]]);p=f[E[t]],_=S[D[t]],C=new l(P,_,p),T.push(C)}let A=a(T);return A.isCanonicalized=!0,A.isRetesselated=!0,A}}},function(t,e,n){const{Connector:o}=n(13),r=n(5),s=n(2),i=n(1),l=n(3),{fromPolygons:a}=n(7),{fromSides:u,fromFakeCSG:c}=n(9),p=n(26),f=n(29),{isCAGValid:h,isSelfIntersecting:d,hasPointInside:m}=n(25),{area:g,getBounds:y}=n(42),{overCutInsideCorners:w}=n(30),{extrudeInOrthonormalBasis:x,extrudeInPlane:b,extrude:v,rotateExtrude:P}=n(43),_=n(45),C=n(31),{expand:S,contract:T,expandedShellOfCAG:M}=n(32);let z=function(){this.sides=[],this.isCanonicalized=!1};z.prototype={union:function(t){let e;e=t instanceof Array?t:[t];let n=this._toCSGWall(-1,1);return n=n.union(e.map((function(t){return t._toCSGWall(-1,1).reTesselated()})),!1,!1),c(n).canonicalized()},subtract:function(t){let e;e=t instanceof Array?t:[t];let n=this._toCSGWall(-1,1);return e.map((function(t){n=n.subtractSub(t._toCSGWall(-1,1),!1,!1)})),n=n.reTesselated(),n=n.canonicalized(),n=c(n),n=n.canonicalized(),n},intersect:function(t){let e;e=t instanceof Array?t:[t];let n=this._toCSGWall(-1,1);return e.map((function(t){n=n.intersectSub(t._toCSGWall(-1,1),!1,!1)})),n=n.reTesselated(),n=n.canonicalized(),n=c(n),n=n.canonicalized(),n},transform:function(t){let e=t.isMirroring(),n=this.sides.map((function(e){return e.transform(t)})),o=u(n);return e&&(o=o.flipped()),o},flipped:function(){let t=this.sides.map((function(t){return t.flipped()}));return t.reverse(),u(t)},center:function(t){return C({axes:t},[this])},expandedShell:function(t,e){return M(this,t,e)},expand:function(t,e){return S(this,t,e)},contract:function(t,e){return T(this,t,e)},area:function(){return g(this)},getBounds:function(){return y(this)},isSelfIntersecting:function(t){return d(this,t)},extrudeInOrthonormalBasis:function(t,e,n){return x(this,t,e,n)},extrudeInPlane:function(t,e,n,o){return b(this,t,e,n,o)},extrude:function(t){return v(this,t)},rotateExtrude:function(t){return P(this,t)},check:function(){return h(this)},canonicalized:function(){return p(this)},reTesselated:function(){return f(this)},getOutlinePaths:function(){return _(this)},overCutInsideCorners:function(t){return w(this,t)},hasPointInside:function(t){return m(this,t)},toString:function(){let t="CAG ("+this.sides.length+" sides):\n";return this.sides.map((function(e){t+="  "+e.toString()+"\n"})),t},_toCSGWall:function(t,e){let n=this.sides.map((function(n){return n.toPolygon3D(t,e)}));return a(n)},_toVector3DPairs:function(t){let e=this.sides.map((function(t){let e=t.vertex0.pos,n=t.vertex1.pos;return[i.Create(e.x,e.y,0),i.Create(n.x,n.y,0)]}));return void 0!==t&&(e=e.map((function(e){return e.map((function(e){return e.transform(t)}))}))),e},_toPlanePolygons:function(t){t=Object.assign({},{flipped:!1},t);let{flipped:e}=t,n=[0,0,0],u=[0,0,1],c=[0,1,0],p=new o(n,u,c),f=t.translation||n,h=t.axisVector||u,d=t.normalVector||c,m=t.toConnector||new o(f,h,d),g=p.getTransformationTo(m,!1,0),y=this.getBounds();y[0]=y[0].minus(new s(1,1)),y[1]=y[1].plus(new s(1,1));let w=this._toCSGWall(-1,1),x=a([new l([new r(new i(y[0].x,y[0].y,0)),new r(new i(y[1].x,y[0].y,0)),new r(new i(y[1].x,y[1].y,0)),new r(new i(y[0].x,y[1].y,0))])]);return e&&(x=x.invert()),x=x.intersectSub(w),x.polygons.filter((function(t){return Math.abs(t.plane.normal.z)>.99})).map((function(t){return t.transform(g)}))},_toWallPolygons:function(t){let e=new o([0,0,0],[0,0,1],[0,1,0]),n=t.toConnector1,s=t.toConnector2;if(!(n instanceof o&&s instanceof o))throw new Error("could not parse Connector arguments toConnector1 or toConnector2");if(t.cag&&t.cag.sides.length!==this.sides.length)throw new Error("target cag needs same sides count as start cag");let i=t.cag||this,a=e.getTransformationTo(n,!1,0),u=e.getTransformationTo(s,!1,0),c=this._toVector3DPairs(a),p=i._toVector3DPairs(u),f=[];return c.forEach((function(t,e){f.push(new l([new r(p[e][1]),new r(p[e][0]),new r(t[0])])),f.push(new l([new r(p[e][1]),new r(t[0]),new r(t[1])]))})),f},toPoints:function(){let t=this.sides.map((function(t){return t.vertex0.pos}));return t.length>0&&t.push(t.shift()),t},toCompactBinary:function(){let t=this.canonicalized(),e=t.sides.length,n={},o=[],r=0,s=new Uint32Array(2*e),i=0;t.sides.map((function(t){[t.vertex0,t.vertex1].map((function(t){let e,l=t.getTag();l in n?e=n[l]:(e=r++,n[l]=e,o.push(t)),s[i++]=e}))}));let l=new Float64Array(2*r),a=0;return o.map((function(t){let e=t.pos;l[a++]=e._x,l[a++]=e._y})),{class:"CAG",sideVertexIndices:s,vertexData:l}}},t.exports=z},function(t,e,n){const o=n(17),r=n(2),s=n(14),{areaEPS:i}=n(0),{isSelfIntersecting:l,contains:a}=n(25),{union:u,difference:c}=n(39),p=function(t){let e=new(n(8));return e.sides=t,e},f=function(t){if(!t)throw new Error("points parameter must be defined");if(!Array.isArray(t))throw new Error("points parameter must be an array");if(void 0!==t[0].x||"number"==typeof t[0][0])return h(t);if("object"==typeof t[0][0])return d(t);throw new Error("Unsupported points list format")},h=function(t){if(t.length<3)throw new Error("CAG shape needs at least 3 points");let e=[],n=new s(new r(t[t.length-1]));t.map((function(t){let i=new s(new r(t));e.push(new o(n,i)),n=i}));let a=p(e);if(l(a))throw new Error("Polygon is self intersecting!");let u=a.area();if(Math.abs(u)<i)throw new Error("Degenerate polygon!");return u<0&&(a=a.flipped()),a.canonicalized()},d=function(t){if(1===t.length)return f(t[0]);let e=[];t.forEach(t=>{e.push(h(t))});let n={};e.forEach((t,o)=>{e.forEach((e,r)=>{t!==e&&(n[o]||(n[o]={parents:[],isHole:!1}),n[r]||(n[r]={parents:[],isHole:!1}),a(e,t)&&(n[o].parents.push(r),n[o].isHole=!!(n[o].parents.length%2),n[r].isHole=!!(n[r].parents.length%2)))})});let o=null;for(key in n)o=n[key],o.isHole&&(delete n[key],o.parents.forEach(t=>{e[t]=c(e[t],e[key])}));let r=p([]);for(key in n)r=u(r,e[key]);return r};t.exports={fromSides:p,fromObject:function(t){let e=t.sides.map((function(t){return o.fromObject(t)})),n=p(e);return n.isCanonicalized=t.isCanonicalized,n},fromPoints:f,fromPointsNoCheck:function(t){let e=[],n=new r(t[t.length-1]),i=new s(n);return t.map((function(t){let n=new r(t),l=new s(n),a=new o(i,l);e.push(a),i=l})),p(e)},fromPath2:function(t){if(!t.isClosed())throw new Error("The path should be closed!");return f(t.getPoints())},fromFakeCSG:function(t){let e=t.polygons.map((function(t){return o._fromFakePolygon(t)})).filter((function(t){return null!==t}));return p(e)},fromCompactBinary:function(t){if("CAG"!==t.class)throw new Error("Not a CAG");let e=[],n=t.vertexData,i=n.length/2,l=0;for(let t=0;t<i;t++){let t=n[l++],o=n[l++],i=new r(t,o),a=new s(i);e.push(a)}let a=[],u=t.sideVertexIndices.length/2;l=0;for(let n=0;n<u;n++){let n=t.sideVertexIndices[l++],r=t.sideVertexIndices[l++],s=new o(e[n],e[r]);a.push(s)}let c=p(a);return c.isCanonicalized=!0,c}}},function(t,e,n){const o=n(1),r=n(2),s=n(11),i=n(4),l=function(t){this.elements=arguments.length>=1?t:[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]};l.prototype={plus:function(t){for(var e=[],n=0;n<16;n++)e[n]=this.elements[n]+t.elements[n];return new l(e)},minus:function(t){for(var e=[],n=0;n<16;n++)e[n]=this.elements[n]-t.elements[n];return new l(e)},multiply:function(t){var e=this.elements[0],n=this.elements[1],o=this.elements[2],r=this.elements[3],s=this.elements[4],i=this.elements[5],a=this.elements[6],u=this.elements[7],c=this.elements[8],p=this.elements[9],f=this.elements[10],h=this.elements[11],d=this.elements[12],m=this.elements[13],g=this.elements[14],y=this.elements[15],w=t.elements[0],x=t.elements[1],b=t.elements[2],v=t.elements[3],P=t.elements[4],_=t.elements[5],C=t.elements[6],S=t.elements[7],T=t.elements[8],M=t.elements[9],z=t.elements[10],k=t.elements[11],E=t.elements[12],D=t.elements[13],A=t.elements[14],V=t.elements[15],j=[];return j[0]=e*w+n*P+o*T+r*E,j[1]=e*x+n*_+o*M+r*D,j[2]=e*b+n*C+o*z+r*A,j[3]=e*v+n*S+o*k+r*V,j[4]=s*w+i*P+a*T+u*E,j[5]=s*x+i*_+a*M+u*D,j[6]=s*b+i*C+a*z+u*A,j[7]=s*v+i*S+a*k+u*V,j[8]=c*w+p*P+f*T+h*E,j[9]=c*x+p*_+f*M+h*D,j[10]=c*b+p*C+f*z+h*A,j[11]=c*v+p*S+f*k+h*V,j[12]=d*w+m*P+g*T+y*E,j[13]=d*x+m*_+g*M+y*D,j[14]=d*b+m*C+g*z+y*A,j[15]=d*v+m*S+g*k+y*V,new l(j)},clone:function(){var t=this.elements.map((function(t){return t}));return new l(t)},rightMultiply1x3Vector:function(t){var e=t._x,n=t._y,r=t._z,s=e*this.elements[0]+n*this.elements[1]+r*this.elements[2]+1*this.elements[3],i=e*this.elements[4]+n*this.elements[5]+r*this.elements[6]+1*this.elements[7],l=e*this.elements[8]+n*this.elements[9]+r*this.elements[10]+1*this.elements[11],a=e*this.elements[12]+n*this.elements[13]+r*this.elements[14]+1*this.elements[15];if(1!==a){var u=1/a;s*=u,i*=u,l*=u}return new o(s,i,l)},leftMultiply1x3Vector:function(t){var e=t._x,n=t._y,r=t._z,s=e*this.elements[0]+n*this.elements[4]+r*this.elements[8]+1*this.elements[12],i=e*this.elements[1]+n*this.elements[5]+r*this.elements[9]+1*this.elements[13],l=e*this.elements[2]+n*this.elements[6]+r*this.elements[10]+1*this.elements[14],a=e*this.elements[3]+n*this.elements[7]+r*this.elements[11]+1*this.elements[15];if(1!==a){var u=1/a;s*=u,i*=u,l*=u}return new o(s,i,l)},rightMultiply1x2Vector:function(t){var e=t.x,n=t.y,o=e*this.elements[0]+n*this.elements[1]+0*this.elements[2]+1*this.elements[3],s=e*this.elements[4]+n*this.elements[5]+0*this.elements[6]+1*this.elements[7],i=(this.elements[8],this.elements[9],this.elements[10],this.elements[11],e*this.elements[12]+n*this.elements[13]+0*this.elements[14]+1*this.elements[15]);if(1!==i){var l=1/i;o*=l,s*=l,l}return new r(o,s)},leftMultiply1x2Vector:function(t){var e=t.x,n=t.y,o=e*this.elements[0]+n*this.elements[4]+0*this.elements[8]+1*this.elements[12],s=e*this.elements[1]+n*this.elements[5]+0*this.elements[9]+1*this.elements[13],i=(this.elements[2],this.elements[6],this.elements[10],this.elements[14],e*this.elements[3]+n*this.elements[7]+0*this.elements[11]+1*this.elements[15]);if(1!==i){var l=1/i;o*=l,s*=l,l}return new r(o,s)},isMirroring:function(){var t=new o(this.elements[0],this.elements[4],this.elements[8]),e=new o(this.elements[1],this.elements[5],this.elements[9]),n=new o(this.elements[2],this.elements[6],this.elements[10]);return t.cross(e).dot(n)<0}},l.unity=function(){return new l},l.rotationX=function(t){var e=t*Math.PI*(1/180),n=Math.cos(e),o=Math.sin(e);return new l([1,0,0,0,0,n,o,0,0,-o,n,0,0,0,0,1])},l.rotationY=function(t){var e=t*Math.PI*(1/180),n=Math.cos(e),o=Math.sin(e);return new l([n,0,-o,0,0,1,0,0,o,0,n,0,0,0,0,1])},l.rotationZ=function(t){var e=t*Math.PI*(1/180),n=Math.cos(e),o=Math.sin(e);return new l([n,o,0,0,-o,n,0,0,0,0,1,0,0,0,0,1])},l.rotation=function(t,e,n){t=new o(t),e=new o(e);var r=i.fromNormalAndPoint(e,t),a=new s(r),u=l.translation(t.negated());return u=(u=(u=(u=u.multiply(a.getProjectionMatrix())).multiply(l.rotationZ(n))).multiply(a.getInverseProjectionMatrix())).multiply(l.translation(t))},l.translation=function(t){var e=new o(t),n=[1,0,0,0,0,1,0,0,0,0,1,0,e.x,e.y,e.z,1];return new l(n)},l.mirroring=function(t){var e=t.normal.x,n=t.normal.y,o=t.normal.z,r=t.w;return new l([1-2*e*e,-2*n*e,-2*o*e,0,-2*e*n,1-2*n*n,-2*o*n,0,-2*e*o,-2*n*o,1-2*o*o,0,2*e*r,2*n*r,2*o*r,1])},l.scaling=function(t){var e=new o(t),n=[e.x,0,0,0,0,e.y,0,0,0,0,e.z,0,0,0,0,1];return new l(n)},t.exports=l},function(t,e,n){const o=n(2),r=n(1),s=n(20),i=n(16),l=n(4),a=function(t,e){e=arguments.length<2?t.normal.randomNonParallelVector():new r(e),this.v=t.normal.cross(e).unit(),this.u=this.v.cross(t.normal),this.plane=t,this.planeorigin=t.normal.times(t.w)};a.GetCartesian=function(t,e){let n,o,s=t+"/"+e;if("X/Y"===s)n=[0,0,1],o=[1,0,0];else if("Y/-X"===s)n=[0,0,1],o=[0,1,0];else if("-X/-Y"===s)n=[0,0,1],o=[-1,0,0];else if("-Y/X"===s)n=[0,0,1],o=[0,-1,0];else if("-X/Y"===s)n=[0,0,-1],o=[-1,0,0];else if("-Y/-X"===s)n=[0,0,-1],o=[0,-1,0];else if("X/-Y"===s)n=[0,0,-1],o=[1,0,0];else if("Y/X"===s)n=[0,0,-1],o=[0,1,0];else if("X/Z"===s)n=[0,-1,0],o=[1,0,0];else if("Z/-X"===s)n=[0,-1,0],o=[0,0,1];else if("-X/-Z"===s)n=[0,-1,0],o=[-1,0,0];else if("-Z/X"===s)n=[0,-1,0],o=[0,0,-1];else if("-X/Z"===s)n=[0,1,0],o=[-1,0,0];else if("-Z/-X"===s)n=[0,1,0],o=[0,0,-1];else if("X/-Z"===s)n=[0,1,0],o=[1,0,0];else if("Z/X"===s)n=[0,1,0],o=[0,0,1];else if("Y/Z"===s)n=[1,0,0],o=[0,1,0];else if("Z/-Y"===s)n=[1,0,0],o=[0,0,1];else if("-Y/-Z"===s)n=[1,0,0],o=[0,-1,0];else if("-Z/Y"===s)n=[1,0,0],o=[0,0,-1];else if("-Y/Z"===s)n=[-1,0,0],o=[0,-1,0];else if("-Z/-Y"===s)n=[-1,0,0],o=[0,0,-1];else if("Y/-Z"===s)n=[-1,0,0],o=[0,1,0];else{if("Z/Y"!==s)throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");n=[-1,0,0],o=[0,0,1]}return new a(new l(new r(n),0),new r(o))},a.Z0Plane=function(){let t=new l(new r([0,0,1]),0);return new a(t,new r([1,0,0]))},a.prototype={getProjectionMatrix:function(){return new(n(10))([this.u.x,this.v.x,this.plane.normal.x,0,this.u.y,this.v.y,this.plane.normal.y,0,this.u.z,this.v.z,this.plane.normal.z,0,0,0,-this.plane.w,1])},getInverseProjectionMatrix:function(){const t=n(10);let e=this.plane.normal.times(this.plane.w);return new t([this.u.x,this.u.y,this.u.z,0,this.v.x,this.v.y,this.v.z,0,this.plane.normal.x,this.plane.normal.y,this.plane.normal.z,0,e.x,e.y,e.z,1])},to2D:function(t){return new o(t.dot(this.u),t.dot(this.v))},to3D:function(t){return this.planeorigin.plus(this.u.times(t.x)).plus(this.v.times(t.y))},line3Dto2D:function(t){let e=t.point,n=t.direction.plus(e),o=this.to2D(e),r=this.to2D(n);return s.fromPoints(o,r)},line2Dto3D:function(t){let e=t.origin(),n=t.direction().plus(e),o=this.to3D(e),r=this.to3D(n);return i.fromPoints(o,r)},transform:function(t){let e=this.plane.transform(t),n=this.u.transform(t),o=new r(0,0,0).transform(t),s=n.minus(o);return new a(e,s)}},t.exports=a},function(t,e,n){const o=n(37),r=n(3),s=n(4),i=n(11),l=(n(8),n(21)),{fromPolygons:a}=n(7),u=n(48),c=n(26),p=n(29),{bounds:f}=n(49),{projectToOrthoNormalBasis:h}=n(50),{lieFlat:d,getTransformationToFlatLying:m,getTransformationAndInverseTransformationToFlatLying:g}=n(30),{sectionCut:y,cutByPlane:w}=n(51),x=n(31),{expand:b,contract:v,expandedShellOfCCSG:P}=n(32);let _=function(){this.polygons=[],this.properties=new l,this.isCanonicalized=!0,this.isRetesselated=!0};_.prototype={union:function(t){let e,n;for(t instanceof Array?(e=t.slice(0),e.push(this)):e=[this,t],n=1;n<e.length;n+=2)e.push(e[n-1].unionSub(e[n]));return e[n-1].reTesselated().canonicalized()},unionSub:function(t,e,n){if(this.mayOverlap(t)){let r=new o(this.polygons),s=new o(t.polygons);r.clipTo(s,!1),s.clipTo(r),s.invert(),s.clipTo(r),s.invert();let i=r.allPolygons().concat(s.allPolygons()),l=a(i);return l.properties=this.properties._merge(t.properties),e&&(l=l.reTesselated()),n&&(l=l.canonicalized()),l}return this.unionForNonIntersecting(t)},unionForNonIntersecting:function(t){let e=this.polygons.concat(t.polygons),n=a(e);return n.properties=this.properties._merge(t.properties),n.isCanonicalized=this.isCanonicalized&&t.isCanonicalized,n.isRetesselated=this.isRetesselated&&t.isRetesselated,n},subtract:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.subtractSub(e[t],o,o)}return n},subtractSub:function(t,e,n){let r=new o(this.polygons),s=new o(t.polygons);r.invert(),r.clipTo(s),s.clipTo(r,!0),r.addPolygons(s.allPolygons()),r.invert();let i=a(r.allPolygons());return i.properties=this.properties._merge(t.properties),e&&(i=i.reTesselated()),n&&(i=i.canonicalized()),i},intersect:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.intersectSub(e[t],o,o)}return n},intersectSub:function(t,e,n){let r=new o(this.polygons),s=new o(t.polygons);r.invert(),s.clipTo(r),s.invert(),r.clipTo(s),s.clipTo(r),r.addPolygons(s.allPolygons()),r.invert();let i=a(r.allPolygons());return i.properties=this.properties._merge(t.properties),e&&(i=i.reTesselated()),n&&(i=i.canonicalized()),i},invert:function(){let t=this.polygons.map((function(t){return t.flipped()}));return a(t)},transform1:function(t){let e=this.polygons.map((function(e){return e.transform(t)})),n=a(e);return n.properties=this.properties._transform(t),n.isRetesselated=this.isRetesselated,n},transform:function(t){let e=t.isMirroring(),n={},o={},s=this.polygons.map((function(s){let i,l=s.plane,a=l.getTag();a in o?i=o[a]:(i=l.transform(t),o[a]=i);let u=s.vertices.map((function(e){let o,r=e.getTag();return r in n?o=n[r]:(o=e.transform(t),n[r]=o),o}));return e&&u.reverse(),new r(u,s.shared,i)})),i=a(s);return i.properties=this.properties._transform(t),i.isRetesselated=this.isRetesselated,i.isCanonicalized=this.isCanonicalized,i},center:function(t){return x({axes:t},[this])},expand:function(t,e){return b(this,t,e)},contract:function(t,e){return v(this,t,e)},expandedShell:function(t,e,n){return P(this,t,e,n)},stretchAtPlane:function(t,e,n){let o=s.fromNormalAndPoint(t,e),r=new i(o),l=this.sectionCut(r).extrudeInOrthonormalBasis(r,n),a=this.cutByPlane(o),u=this.cutByPlane(o.flipped());return a.union([l,u.translate(o.normal.times(n))])},canonicalized:function(){return c(this)},reTesselated:function(){return p(this)},fixTJunctions:function(){return u(a,this)},getBounds:function(){return f(this)},mayOverlap:function(t){if(0===this.polygons.length||0===t.polygons.length)return!1;{let e=f(this),n=f(t);return!(e[1].x<n[0].x)&&(!(e[0].x>n[1].x)&&(!(e[1].y<n[0].y)&&(!(e[0].y>n[1].y)&&(!(e[1].z<n[0].z)&&!(e[0].z>n[1].z)))))}},cutByPlane:function(t){return w(this,t)},connectTo:function(t,e,n,o){let r=t.getTransformationTo(e,n,o);return this.transform(r)},setShared:function(t){let e=this.polygons.map((function(e){return new r(e.vertices,t,e.plane)})),n=a(e);return n.properties=this.properties,n.isRetesselated=this.isRetesselated,n.isCanonicalized=this.isCanonicalized,n},setColor:function(t){let e=r.Shared.fromColor.apply(this,arguments);return this.setShared(e)},getTransformationAndInverseTransformationToFlatLying:function(){return g(this)},getTransformationToFlatLying:function(){return m(this)},lieFlat:function(){return d(this)},projectToOrthoNormalBasis:function(t){return h(this,t)},sectionCut:function(t){return y(this,t)},getFeatures:function(t){t instanceof Array||(t=[t]);let e=this.toTriangles().map((function(e){return e.getTetraFeatures(t)})).reduce((function(t,e){return e.map((function(e,n){return e+(0===t?0:t[n])}))}),0);return 1===e.length?e[0]:e},toPolygons:function(){return this.polygons},toString:function(){let t="CSG solid:\n";return this.polygons.map((function(e){t+=e.toString()})),t},toCompactBinary:function(){let t=this.canonicalized(),e=t.polygons.length,n=0,o=0,r={},s=[],i=0,l={},a=[],u=[],c={},p=0;t.polygons.map((function(t){t.vertices.map((function(t){++n;let e=t.getTag();e in r||(r[e]=o++,s.push(t))}));let e=t.plane.getTag();e in l||(l[e]=i++,a.push(t.plane));let f=t.shared.getTag();f in c||(c[f]=p++,u.push(t.shared))}));let f=new Uint32Array(e),h=new Uint32Array(e),d=new Uint32Array(n),m=new Uint32Array(e),g=new Float64Array(3*o),y=new Float64Array(4*i),w=0;for(let n=0;n<e;++n){let e=t.polygons[n];f[n]=e.vertices.length,e.vertices.map((function(t){let e=t.getTag(),n=r[e];d[w++]=n}));let o=e.plane.getTag(),s=l[o];m[n]=s;let i=e.shared.getTag(),a=c[i];h[n]=a}let x=0;s.map((function(t){const e=t.pos;g[x++]=e._x,g[x++]=e._y,g[x++]=e._z}));let b=0;return a.map((function(t){const e=t.normal;y[b++]=e._x,y[b++]=e._y,y[b++]=e._z,y[b++]=t.w})),{class:"CSG",numPolygons:e,numVerticesPerPolygon:f,polygonPlaneIndexes:m,polygonSharedIndexes:h,polygonVertices:d,vertexData:g,planeData:y,shared:u}},toTriangles:function(){let t=[];return this.polygons.forEach((function(e){let n=e.vertices[0];for(let o=e.vertices.length-3;o>=0;o--)t.push(new r([n,e.vertices[o+1],e.vertices[o+2]],e.shared,e.plane))})),t}},t.exports=_},function(t,e,n){const o=n(1),r=n(16),s=n(10),i=n(11),l=n(4),a=function(t,e,n){this.point=new o(t),this.axisvector=new o(e).unit(),this.normalvector=new o(n).unit()};a.prototype={normalized:function(){let t=this.axisvector.unit(),e=this.normalvector.cross(t).unit(),n=t.cross(e);return new a(this.point,t,n)},transform:function(t){let e=this.point.multiply4x4(t),n=this.point.plus(this.axisvector).multiply4x4(t).minus(e),o=this.point.plus(this.normalvector).multiply4x4(t).minus(e);return new a(e,n,o)},getTransformationTo:function(t,e,n){e=!!e,n=n?Number(n):0;let r=this.normalized();t=t.normalized();let a=s.translation(this.point.negated()),u=l.anyPlaneFromVector3Ds(new o(0,0,0),r.axisvector,t.axisvector),c=new i(u),p=c.to2D(r.axisvector).angle(),f=c.to2D(t.axisvector).angle(),h=180*(f-p)/Math.PI;e&&(h+=180),a=a.multiply(c.getProjectionMatrix()),a=a.multiply(s.rotationZ(h)),a=a.multiply(c.getInverseProjectionMatrix());let d=r.transform(a),m=l.fromNormalAndPoint(t.axisvector,new o(0,0,0)),g=new i(m);return p=g.to2D(d.normalvector).angle(),f=g.to2D(t.normalvector).angle(),h=180*(f-p)/Math.PI,h+=n,a=a.multiply(g.getProjectionMatrix()),a=a.multiply(s.rotationZ(h)),a=a.multiply(g.getInverseProjectionMatrix()),a=a.multiply(s.translation(t.point)),a},axisLine:function(){return new r(this.point,this.axisvector)},extend:function(t){let e=this.point.plus(this.axisvector.unit().times(t));return new a(e,this.axisvector,this.normalvector)}};const u=function(t){this.connectors_=t?t.slice():[]};u.defaultNormal=[0,0,1],u.fromPath2D=function(t,e,n){if(3===arguments.length)return u._fromPath2DTangents(t,e,n);if(2===arguments.length)return u._fromPath2DExplicit(t,e);throw new Error("call with path2D and either 2 direction vectors, or a function returning direction vectors")},u._fromPath2DTangents=function(t,e,n){let o,r=t.points.length,s=new u([new a(t.points[0],e,u.defaultNormal)]);return t.points.slice(1,r-1).forEach((function(e,n){o=t.points[n+2].minus(t.points[n]).toVector3D(0),s.appendConnector(new a(e.toVector3D(0),o,u.defaultNormal))}),this),s.appendConnector(new a(t.points[r-1],n,u.defaultNormal)),s.closed=t.closed,s},u._fromPath2DExplicit=function(t,e){let n=new u(t.points.map((function(t,n){return new a(t.toVector3D(0),o.Create(1,0,0).rotateZ(function(t,e,n){return"function"==typeof t&&(t=t(e,n)),t}(e,t,n)),u.defaultNormal)}),this));return n.closed=t.closed,n},u.prototype={setClosed:function(t){this.closed=!!t},appendConnector:function(t){this.connectors_.push(t)},followWith:function(t){const e=n(12);function o(t,e){return"function"==typeof t&&(t=t(e.point,e.axisvector,e.normalvector)),t}this.verify();let r,s=[],i=this.connectors_[this.connectors_.length-1],l=o(t,i);return this.connectors_.forEach((function(e,n){r=o(t,e),n||this.closed?s.push.apply(s,l._toWallPolygons({toConnector1:i,toConnector2:e,cag:r})):s.push.apply(s,r._toPlanePolygons({toConnector:e,flipped:!0})),n!==this.connectors_.length-1||this.closed||s.push.apply(s,r._toPlanePolygons({toConnector:e})),l=r,i=e}),this),e.fromPolygons(s).reTesselated().canonicalized()},verify:function(){let t,e;for(let n=0;n<this.connectors_.length-1;n++){if(t=this.connectors_[n],e=this.connectors_[n+1],e.point.minus(t.point).dot(t.axisvector)<=0)throw new Error("Invalid ConnectorList. Each connectors position needs to be within a <90deg range of previous connectors axisvector");if(t.axisvector.dot(e.axisvector)<=0)throw new Error("invalid ConnectorList. No neighboring connectors axisvectors may span a >=90deg angle")}}},t.exports={Connector:a,ConnectorList:u}},function(t,e,n){const o=n(2),{getTag:r}=n(0),s=function(t){this.pos=t};s.fromObject=function(t){return new s(new o(t.pos._x,t.pos._y))},s.prototype={toString:function(){return"("+this.pos.x.toFixed(5)+","+this.pos.y.toFixed(5)+")"},getTag:function(){var t=this.tag;return t||(t=r(),this.tag=t),t}},t.exports=s},function(t,e,n){const o=n(1),r=n(2),s=function(t,e,n){var o=n;return t&&e in t&&(o=t[e]),o};t.exports={parseOption:s,parseOptionAsInt:function(t,e,n){var o=s(t,e,n);if(o=Number(Math.floor(o)),isNaN(o))throw new Error("Parameter "+e+" should be a number");return o},parseOptionAsFloat:function(t,e,n){var o=s(t,e,n);if("string"==typeof o&&(o=Number(o)),isNaN(o)||"number"!=typeof o)throw new Error("Parameter "+e+" should be a number");return o},parseOptionAsBool:function(t,e,n){var o=s(t,e,n);return"string"==typeof o&&("true"===o?o=!0:("false"===o||0===o)&&(o=!1)),o=!!o},parseOptionAs3DVector:function(t,e,n){var r=s(t,e,n);return r=new o(r)},parseOptionAs2DVector:function(t,e,n){var o=s(t,e,n);return o=new r(o)},parseOptionAs3DVectorList:function(t,e,n){return s(t,e,n).map((function(t){return new o(t)}))}}},function(t,e,n){const o=n(1),{EPS:r}=n(0),{solve2Linear:s}=n(6),i=function(t,e){t=new o(t),e=new o(e),this.point=t,this.direction=e.unit()};i.fromPoints=function(t,e){t=new o(t);let n=(e=new o(e)).minus(t);return new i(t,n)},i.fromPlanes=function(t,e){let n=t.normal.cross(e.normal),l=n.length();if(l<r)throw new Error("Parallel planes");n=n.times(1/l);let a,u=Math.abs(n.x),c=Math.abs(n.y),p=Math.abs(n.z);if(u>=c&&u>=p){let n=s(t.normal.y,t.normal.z,e.normal.y,e.normal.z,t.w,e.w);a=new o(0,n[0],n[1])}else if(c>=u&&c>=p){let n=s(t.normal.x,t.normal.z,e.normal.x,e.normal.z,t.w,e.w);a=new o(n[0],0,n[1])}else{let n=s(t.normal.x,t.normal.y,e.normal.x,e.normal.y,t.w,e.w);a=new o(n[0],n[1],0)}return new i(a,n)},i.prototype={intersectWithPlane:function(t){let e=(t.w-t.normal.dot(this.point))/t.normal.dot(this.direction);return this.point.plus(this.direction.times(e))},clone:function(t){return new i(this.point.clone(),this.direction.clone())},reverse:function(){return new i(this.point.clone(),this.direction.negated())},transform:function(t){let e=this.point.multiply4x4(t),n=this.point.plus(this.direction).multiply4x4(t).minus(e);return new i(e,n)},closestPointOnLine:function(t){let e=(t=new o(t)).minus(this.point).dot(this.direction)/this.direction.dot(this.direction);return this.point.plus(this.direction.times(e))},distanceToPoint:function(t){t=new o(t);let e=this.closestPointOnLine(t);return t.minus(e).length()},equals:function(t){if(!this.direction.equals(t.direction))return!1;return!(this.distanceToPoint(t.point)>r)}},t.exports=i},function(t,e,n){const o=n(2),r=n(14),s=n(5),i=n(3),{getTag:l}=n(0),a=function(t,e){if(!(t instanceof r))throw new Error("Assertion failed");if(!(e instanceof r))throw new Error("Assertion failed");this.vertex0=t,this.vertex1=e};a.fromObject=function(t){var e=r.fromObject(t.vertex0),n=r.fromObject(t.vertex1);return new a(e,n)},a._fromFakePolygon=function(t){if(t.vertices.length<4)return null;var e=[],n=t.vertices.filter((function(t,n){return t.pos.z>0&&(e.push(n),!0)})).map((function(t){return new o(t.pos.x,t.pos.y)}));if(2!==n.length)throw new Error("Assertion failed: _fromFakePolygon: not enough points found");var s=e[1]-e[0];if(1!==s&&3!==s)throw new Error("Assertion failed: _fromFakePolygon: unknown index ordering");return 1===s&&n.reverse(),new a(new r(n[0]),new r(n[1]))},a.prototype={toString:function(){return this.vertex0+" -> "+this.vertex1},toPolygon3D:function(t,e){const n=[new s(this.vertex0.pos.toVector3D(t)),new s(this.vertex1.pos.toVector3D(t)),new s(this.vertex1.pos.toVector3D(e)),new s(this.vertex0.pos.toVector3D(e))];return new i(n)},transform:function(t){var e=this.vertex0.pos.transform(t),n=this.vertex1.pos.transform(t);return new a(new r(e),new r(n))},flipped:function(){return new a(this.vertex1,this.vertex0)},direction:function(){return this.vertex1.pos.minus(this.vertex0.pos)},getTag:function(){var t=this.tag;return t||(t=l(),this.tag=t),t},lengthSquared:function(){let t=this.vertex1.pos.x-this.vertex0.pos.x,e=this.vertex1.pos.y-this.vertex0.pos.y;return t*t+e*e},length:function(){return Math.sqrt(this.lengthSquared())}},t.exports=a},function(t,e,n){const o=n(2),{EPS:r,angleEPS:s}=n(0),{parseOptionAs2DVector:i,parseOptionAsFloat:l,parseOptionAsInt:a,parseOptionAsBool:u}=n(15),{defaultResolution2D:c}=n(0),p=n(14),f=n(17),h=function(t,e){t=t||[];let n=null;(e=!!e)&&t.length>0&&(n=new o(t[t.length-1]));let s=[];t.map((function(t){t=new o(t);let e=!1;if(null!==n){e=t.distanceTo(n)<r}e||s.push(t),n=t})),this.points=s,this.closed=e};h.arc=function(t){let e=i(t,"center",0),n=l(t,"radius",1),r=l(t,"startangle",0),p=l(t,"endangle",360),f=a(t,"resolution",c),d=u(t,"maketangent",!1);for(;p-r>=720;)p-=360;for(;p-r<=-720;)p+=360;let m,g=[],y=Math.abs(p-r);if(y<s)m=o.fromAngle(r/180*Math.PI).times(n),g.push(m.plus(e));else{let t=Math.floor(f*y/360)+1,s=.5*t/y;s>.25&&(s=.25);let i=d?t+2:t;for(let l=0;l<=i;l++){let i=l;d&&(i=(l-1)*(t-2*s)/t+s,i<0&&(i=0),i>t&&(i=t));let a=r+i*(p-r)/t;m=o.fromAngle(a/180*Math.PI).times(n),g.push(m.plus(e))}}return new h(g,!1)},h.prototype={concat:function(t){if(this.closed||t.closed)throw new Error("Paths must not be closed");let e=this.points.concat(t.points);return new h(e)},getPoints:function(){return this.points},appendPoint:function(t){if(this.closed)throw new Error("Path must not be closed");t=new o(t);let e=this.points.concat([t]);return new h(e)},appendPoints:function(t){if(this.closed)throw new Error("Path must not be closed");let e=this.points;return t.forEach((function(t){e.push(new o(t))})),new h(e)},close:function(){return new h(this.points,!0)},isClosed:function(){return this.closed},getTurn:function(){const t=this.points;let e=0,n=t.length-1;for(let o=0;o<t.length;n=o++)e+=t[n].x*t[o].y-t[n].y*t[o].x;return e>0?"clockwise":e<0?"counter-clockwise":"straight"},rectangularExtrude:function(t,e,n){return this.expandToCAG(t/2,n).extrude({offset:[0,0,e]})},expandToCAG:function(t,e){const o=n(8);let r,s=[],i=this.points.length,l=0;this.closed&&i>2&&(l=-1);for(let t=l;t<i;t++){let e=t;e<0&&(e=i-1);let n=this.points[e],o=new p(n);if(t>l){let t=new f(r,o);s.push(t)}r=o}return o.fromSides(s).expandedShell(t,e)},innerToCAG:function(){const t=n(8);if(!this.closed)throw new Error("The path should be closed!");return t.fromPoints(this.points)},transform:function(t){let e=this.points.map((function(e){return e.multiply4x4(t)}));return new h(e,this.closed)},appendBezier:function(t,e){if(arguments.length<2&&(e={}),this.closed)throw new Error("Path must not be closed");if(!(t instanceof Array))throw new Error("appendBezier: should pass an array of control points");if(t.length<1)throw new Error("appendBezier: need at least 1 control point");if(this.points.length<1)throw new Error("appendBezier: path must already contain a point (the endpoint of the path is used as the starting point for the bezier curve)");let n=a(e,"resolution",c);n<4&&(n=4);let r=[],s=[];s.push(this.points[this.points.length-1]);for(let e=0;e<t.length;++e){let n=t[e];if(null===n){if(0!==e)throw new Error("appendBezier: null can only be passed as the first control point");if(t.length<2)throw new Error("appendBezier: null can only be passed if there is at least one more control point");let o;if("lastBezierControlPoint"in this)o=this.lastBezierControlPoint;else{if(this.points.length<2)throw new Error("appendBezier: null is passed as a control point but this requires a previous bezier curve or at least two points in the existing path");o=this.points[this.points.length-2]}n=this.points[this.points.length-1].times(2).minus(o)}else n=new o(n);s.push(n)}let i=s.length-1,l=1;for(let t=0;t<=i;++t)t>0&&(l*=t),r.push(l);let u=[];for(let t=0;t<=i;++t){let e=r[i]/(r[t]*r[i-t]);u.push(e)}let p=function(t){let e=1,n=Math.pow(1-t,i),r=1!==t?1/(1-t):1,l=new o(0,0);for(let o=0;o<=i;++o){o===i&&(n=1);let a=u[o]*e*n;l=l.plus(s[o].times(a)),e*=t,n*=r}return l},f=[],d=[],m=i+1;for(let t=0;t<m;++t){let e=t/(m-1),n=p(e);f.push(n),d.push(e)}let g=1,y=2*Math.PI/n,w=Math.sin(y);for(;g<f.length-1;){let t=f[g].minus(f[g-1]).unit(),e=f[g+1].minus(f[g]).unit(),n=t.cross(e);if(Math.abs(n)>w){let t=d[g-1],e=d[g+1],n=t+1*(e-t)/3,o=t+2*(e-t)/3,r=p(n),s=p(o);f.splice(g,1,r,s),d.splice(g,1,n,o),g--,g<1&&(g=1)}else++g}f=this.points.concat(f.slice(1));let x=new h(f);return x.lastBezierControlPoint=s[s.length-2],x},appendArc:function(t,e){let n=1e5;if(arguments.length<2&&(e={}),this.closed)throw new Error("Path must not be closed");if(this.points.length<1)throw new Error("appendArc: path must already contain a point (the endpoint of the path is used as the starting point for the arc)");let r,s,i=a(e,"resolution",c);if(i<4&&(i=4),"xradius"in e||"yradius"in e){if("radius"in e)throw new Error("Should either give an xradius and yradius parameter, or a radius parameter");r=l(e,"xradius",0),s=l(e,"yradius",0)}else r=l(e,"radius",0),s=r;let p=l(e,"xaxisrotation",0),f=u(e,"clockwise",!1),d=u(e,"large",!1),m=this.points[this.points.length-1];t=new o(t),r=Math.round(r*n)/n,s=Math.round(s*n)/n,t=new o(Math.round(t.x*n)/n,Math.round(t.y*n)/n);let g=!f,y=[];if(0===r||0===s)y.push(t);else{r=Math.abs(r),s=Math.abs(s);let e=p*Math.PI/180,l=Math.cos(e),a=Math.sin(e),u=m.minus(t).times(.5),c=Math.round((l*u.x+a*u.y)*n)/n,f=Math.round((-a*u.x+l*u.y)*n)/n,h=new o(c,f),w=h.x*h.x/(r*r)+h.y*h.y/(s*s);if(w>1){let t=Math.sqrt(w);r*=t,s*=t,r=Math.round(r*n)/n,s=Math.round(s*n)/n}let x=Math.sqrt((r*r*s*s-r*r*h.y*h.y-s*s*h.x*h.x)/(r*r*h.y*h.y+s*s*h.x*h.x));g===d&&(x=-x);let b=new o(r*h.y/s,-s*h.x/r).times(x),v=new o(l*b.x-a*b.y,a*b.x+l*b.y).plus(m.plus(t).times(.5)),P=new o((h.x-b.x)/r,(h.y-b.y)/s),_=new o((-h.x-b.x)/r,(-h.y-b.y)/s),C=P.angleRadians(),S=_.angleRadians()-C;S%=2*Math.PI,!g&&S>0?S-=2*Math.PI:g&&S<0&&(S+=2*Math.PI);let T=Math.ceil(Math.abs(S)/(2*Math.PI)*i)+1;T<1&&(T=1);for(let t=1;t<=T;t++){let e=C+t/T*S,n=Math.cos(e),i=Math.sin(e),u=new o(l*r*n-a*s*i,a*r*n+l*s*i).plus(v);y.push(u)}}y=this.points.concat(y);let w=new h(y);return w}},t.exports=h},function(t,e){let n=new Map([[0,"etyp"],[1,"text"],[2,"name"],[3,"nam1"],[5,"hdle"],[6,"ltyp"],[7,"lsty"],[8,"lnam"],[9,"vari"],[10,"pptx"],[11,"sptx"],[12,"tptx"],[13,"fptx"],[20,"ppty"],[21,"spty"],[22,"tpty"],[23,"fpty"],[30,"pptz"],[31,"sptz"],[32,"tptz"],[33,"fptz"],[38,"elev"],[39,"lthk"],[40,"swid"],[41,"ewid"],[42,"bulg"],[43,"cwid"],[48,"lscl"],[50,"ang0"],[51,"ang1"],[60,"visb"],[62,"cnmb"],[67,"spac"],[70,"lflg"],[71,"fvia"],[72,"fvib"],[73,"fvic"],[74,"fvid"],[75,"cflg"],[90,"vlen"],[91,"slen"],[92,"plen"],[93,"flen"],[94,"elen"],[95,"clen"],[100,"sbnm"],[210,"etrx"],[220,"etry"],[230,"etrz"]]);t.exports={colorIndex:[[255,0,0,255],[255,255,0,255],[0,255,0,255],[0,255,255,255],[0,0,255,255],[255,0,255,255],[255,255,255,255],[128,128,128,255],[192,192,192,255],[255,0,0,255],[255,127,127,255],[165,0,0,255],[165,82,82,255],[127,0,0,255],[127,63,63,255],[76,0,0,255],[76,38,38,255],[38,0,0,255],[38,19,19,255],[255,63,0,255],[255,159,127,255],[165,41,0,255],[165,103,82,255],[127,31,0,255],[127,79,63,255],[76,19,0,255],[76,47,38,255],[38,9,0,255],[38,23,19,255],[255,127,0,255],[255,191,127,255],[165,82,0,255],[165,124,82,255],[127,63,0,255],[127,95,63,255],[76,38,0,255],[76,57,38,255],[38,19,0,255],[38,28,19,255],[255,191,0,255],[255,223,127,255],[165,124,0,255],[165,145,82,255],[127,95,0,255],[127,111,63,255],[76,57,0,255],[76,66,38,255],[38,28,0,255],[38,33,19,255],[255,255,0,255],[255,255,127,255],[165,165,0,255],[165,165,82,255],[127,127,0,255],[127,127,63,255],[76,76,0,255],[76,76,38,255],[38,38,0,255],[38,38,19,255],[191,255,0,255],[223,255,127,255],[124,165,0,255],[145,165,82,255],[95,127,0,255],[111,127,63,255],[57,76,0,255],[66,76,38,255],[28,38,0,255],[33,38,19,255],[127,255,0,255],[191,255,127,255],[82,165,0,255],[124,165,82,255],[63,127,0,255],[95,127,63,255],[38,76,0,255],[57,76,38,255],[19,38,0,255],[28,38,19,255],[63,255,0,255],[159,255,127,255],[41,165,0,255],[103,165,82,255],[31,127,0,255],[127,63,255],[19,76,0,255],[47,76,38,255],[9,38,0,255],[23,38,19,255],[0,255,0,255],[127,255,127,255],[0,165,0,255],[82,165,82,255],[0,127,0,255],[63,127,63,255],[0,76,0,255],[38,76,38,255],[0,38,0,255],[19,38,19,255],[0,255,63,255],[127,255,159,255],[0,165,41,255],[82,165,103,255],[0,127,31,255],[63,127,79,255],[0,76,19,255],[38,76,47,255],[0,38,9,255],[19,38,23,255],[0,255,127,255],[127,255,191,255],[0,165,82,255],[82,165,124,255],[0,127,63,255],[63,127,95,255],[0,76,38,255],[38,76,57,255],[0,38,19,255],[19,38,28,255],[0,255,191,255],[127,255,223,255],[0,165,124,255],[82,165,145,255],[0,127,95,255],[63,127,111,255],[0,76,57,255],[38,76,66,255],[0,38,28,255],[19,38,33,255],[0,255,255,255],[127,255,255,255],[0,165,165,255],[82,165,165,255],[0,127,127,255],[63,127,127,255],[0,76,76,255],[38,76,76,255],[0,38,38,255],[19,38,38,255],[0,191,255,255],[127,223,255,255],[0,124,165,255],[82,145,165,255],[0,95,127,255],[63,111,127,255],[0,57,76,255],[38,66,76,255],[0,28,38,255],[19,33,38,255],[0,127,255,255],[127,191,255,255],[0,82,165,255],[82,124,165,255],[0,63,127,255],[63,95,127,255],[0,38,76,255],[38,57,76,255],[0,19,38,255],[19,28,38,255],[0,63,255,255],[127,159,255,255],[0,41,165,255],[82,103,165,255],[0,31,127,255],[63,79,127,255],[0,19,76,255],[38,47,76,255],[0,9,38,255],[19,23,38,255],[0,0,255,255],[127,127,255,255],[0,0,165,255],[82,82,165,255],[0,0,127,255],[63,63,127,255],[0,0,76,255],[38,38,76,255],[0,0,38,255],[19,19,38,255],[63,0,255,255],[159,127,255,255],[41,0,165,255],[103,82,165,255],[31,0,127,255],[79,63,127,255],[19,0,76,255],[47,38,76,255],[9,0,38,255],[23,19,38,255],[127,0,255,255],[191,127,255,255],[82,0,165,255],[124,82,165,255],[63,0,127,255],[95,63,127,255],[38,0,76,255],[57,38,76,255],[19,0,38,255],[28,19,38,255],[191,0,255,255],[223,127,255,255],[124,0,165,255],[145,82,165,255],[95,0,127,255],[111,63,127,255],[57,0,76,255],[66,38,76,255],[28,0,38,255],[33,19,38,255],[255,0,255,255],[255,127,255,255],[165,0,165,255],[165,82,165,255],[127,0,127,255],[127,63,127,255],[76,0,76,255],[76,38,76,255],[38,0,38,255],[38,19,38,255],[255,0,191,255],[255,127,223,255],[165,0,124,255],[165,82,145,255],[127,0,95,255],[127,63,111,255],[76,0,57,255],[76,38,66,255],[38,0,28,255],[38,19,33,255],[255,0,127,255],[255,127,191,255],[165,0,82,255],[165,82,124,255],[127,0,63,255],[127,63,95,255],[76,0,38,255],[76,38,57,255],[38,0,19,255],[38,19,28,255],[255,0,63,255],[255,127,159,255],[165,0,41,255],[165,82,103,255],[127,0,31,255],[127,63,79,255],[76,0,19,255],[76,38,47,255],[38,0,9,255],[38,19,23,255],[84,84,84,255],[118,118,118,255],[160,160,160,255],[192,192,192,255],[224,224,224,255],[0,0,0,255]],BYBLOCK:0,BYLAYER:256,getTLA:function(t){return n.get(t)}}},function(t,e,n){const o=n(2),{solve2Linear:r}=n(6),s=function(t,e){t=new o(t),e=parseFloat(e);let n=t.length();e*=n,t=t.times(1/n),this.normal=t,this.w=e};s.fromPoints=function(t,e){t=new o(t);let n=(e=new o(e)).minus(t).normal().negated().unit(),r=t.dot(n);return new s(n,r)},s.prototype={reverse:function(){return new s(this.normal.negated(),-this.w)},equals:function(t){return t.normal.equals(this.normal)&&t.w===this.w},origin:function(){return this.normal.times(this.w)},direction:function(){return this.normal.normal()},xAtY:function(t){return(this.w-this.normal._y*t)/this.normal.x},absDistanceToPoint:function(t){let e=(t=new o(t)).dot(this.normal);return Math.abs(e-this.w)},intersectWithLine:function(t){let e=r(this.normal.x,this.normal.y,t.normal.x,t.normal.y,this.w,t.w);return e=new o(e),e},transform:function(t){let e=new o(0,0),n=this.normal.times(this.w),r=e.multiply4x4(t),i=this.normal.multiply4x4(t).minus(r),l=n.multiply4x4(t),a=i.dot(l);return new s(i,a)}},t.exports=s},function(t,e){const n=function(){};n.prototype={_transform:function(t){let e=new n;return n.transformObj(this,e,t),e},_merge:function(t){let e=new n;return n.cloneObj(this,e),n.addFrom(e,t),e}},n.transformObj=function(t,e,o){for(let r in t){if("_transform"===r)continue;if("_merge"===r)continue;let s=t[r],i=s;"object"==typeof s&&("transform"in s&&"function"==typeof s.transform?i=s.transform(o):s instanceof Array?(i=[],n.transformObj(s,i,o)):s instanceof n&&(i=new n,n.transformObj(s,i,o))),e[r]=i}},n.cloneObj=function(t,e){for(let o in t){if("_transform"===o)continue;if("_merge"===o)continue;let r=t[o],s=r;if("object"==typeof r)if(r instanceof Array){s=[];for(let t=0;t<r.length;t++)s.push(r[t])}else r instanceof n&&(s=new n,n.cloneObj(r,s));e[o]=s}},n.addFrom=function(t,e){for(let o in e)"_transform"!==o&&"_merge"!==o&&(o in t&&"object"==typeof t[o]&&t[o]instanceof n&&"object"==typeof e[o]&&e[o]instanceof n?n.addFrom(t[o],e[o]):o in t||(t[o]=e[o]))},t.exports=n},function(t,e,n){const{CSG:o,CAG:r}=n(23),{BYBLOCK:s,BYLAYER:i}=n(19);function l(t,e,n){let r=[];if(r.push(new o.Vertex(new o.Vector3D([t.pptx,t.ppty,t.pptz]))),r.push(new o.Vertex(new o.Vector3D([t.sptx,t.spty,t.sptz]))),r.push(new o.Vertex(new o.Vector3D([t.tptx,t.tpty,t.tptz]))),t.fptx){let e=!1;t.tptx!==t.fptx&&(e=!0),t.tpty!==t.fpty&&(e=!0),t.tptz!==t.fptz&&(e=!0),e&&r.push(new o.Vertex(new o.Vector3D([t.fptx,t.fpty,t.fptz])))}let s=y(g(t,e),n.colorindex);return new o.Polygon(r,s)}function a(t,e,n){let r=null;if(t.pptz===t.sptz&0===t.pptz){let e=new o.Vector2D([t.pptx,t.ppty]),n=new o.Vector2D([t.sptx,t.spty]);r=o.Line2D.fromPoints(e,n)}else{let e=new o.Vector3D([t.pptx,t.ppty,t.pptz]),n=new o.Vector3D([t.sptx,t.spty,t.sptz]);r=o.Line3D.fromPoints(e,n)}return r}function u(t){const e=parseInt("00000000000100000",2),n=parseInt("00000000001000000",2),r=parseInt("00000000010000000",2);let s=t.lflg,i=null;return(s&e)===e||(s&n)===n?i=new o.Vector3D([t.pptx,t.ppty,t.pptz]):(s&r)===r?(i=new o.Vector3D([t.pptx,t.ppty,t.pptz]),i.fvia=t.fvia,i.fvib=t.fvib,i.fvic=t.fvic,i.fvid=t.fvid):(i=new o.Vector2D(t.pptx,t.ppty),i.bulg=t.bulg),i}function c(t,e,n,r){if(0===r)t=t.appendPoint([e,n]);else{let s=t.points[t.points.length-1],i=new o.Vector2D(e,n),l=s.distanceTo(i)*((1+Math.pow(r,2))/(4*r)),a=r<0,u=!1,c=Math.atan(r)/(Math.PI/180)*4;t=t.appendArc([e,n],{radius:l,xaxisrotation:c,clockwise:a,large:u})}return t}function p(t,e,n){const s=parseInt("00000000000000001",2);let i=t.vlen,l=t.pptxs,a=t.pptys,u=t.bulgs,p=t.lflg,f=new o.Path2D,h=(p&s)===s;return i!==l.length||i!==a.length||i!==u.length?f:(l.forEach((function(t,e,n){let o=0;e>0&&(o=u[e-1]),f=c(f,l[e],a[e],o)})),h?(f=c(f,l[0],a[0],u[i-1]),f=f.close(),r.fromPoints(f.points)):f)}function f(t,e,n){t.lthk;let r=t.pptx,s=t.ppty,i=t.swid,l=t.ang0,a=t.ang1,u=o.defaultResolution2D;return o.Path2D.arc({center:[r,s],radius:i,startangle:l,endangle:a,resolution:u})}function h(t,e,n){let s=t.lthk,i=t.pptx,l=t.ppty,a=t.swid,u=o.defaultResolution2D;if(0===s){return r.circle({center:[i,l],radius:a,resolution:u})}return r.circle({center:[i,l],radius:a,resolution:u}).extrude({offset:[0,0,s]})}function d(t,e,n){let s=t.pptx,i=t.ppty,l=t.pptz,a=t.sptx,u=t.spty,c=t.sptz,p=t.swid,f=o.defaultResolution2D;if(0===l&&0===c){let t=new o.Vector2D(0,0),e=new o.Vector2D(a,u),n=t.distanceTo(e),l=n*p,c=180*Math.atan2(u,a)/Math.PI;return c<o.EPS&&(c=0),r.ellipse({center:[0,0],radius:[n,l],resolution:f}).rotateZ(c).translate([s,i])}}function m(t,e,n){let r=t.vlen,s=t.pptxs,i=t.pptys,l=t.pptzs,a=t.flen,u=t.fvals,c=y(g(t,e),n.colorindex);o._CSGDEBUG=!1;let p=[];if(r===s.length&&r===i.length&&r===l.length&&a===u.length){let t=function(t){let e=[],n=0;for(;n<t.length;){let o=t[n++],r=[];for(;o>0;)r.push(t[n++]),o--;e.push(r)}return e}(u),e=function(t,e,n){let o=[],r=0;for(;r<t.length;){let s=t[r],i=e[r],l=n[r];o.push([s,i,l]),r++}return o}(s,i,l),r=0;for(;r<t.length;){let s=t[r],i=[],l=[],a=0;for(;a<s.length;){let t=s[a],n=new o.Vector3D(e[t]);i.push(n);let r=new o.Vertex(n);l.push(r),a++}1===n.dxf.angdir&&(l=l.reverse());let u=new o.Polygon(l,c);p.push(u),r++}}return o.fromPolygons(p)}function g(t,e){let n=t.cnmb||-1;if(n===i){n=-1;let o=function(t,e){let n=t.lnam||"0";for(let t of e)if(t.name===n)return t;return null}(t,e);null!==o&&(n=o.cnmb||-1)}else n===s&&(n=-1);return n}function y(t,e){if(t<0)return null;let n=e[t=function(t,e){let n=t%e;return Math.floor(n>=0?n:n+e)}(t,e.length)];return new o.Polygon.Shared(n)}function w(t){const e=parseInt("00000000000000001",2),n=parseInt("00000000000001000",2),r=parseInt("00000000000010000",2);let s=t.lflg,i=null;if((s&n)===n)i=null;else if((s&r)===r)i=new o;else{let t=(s&e)===e;i=new o.Path2D([],t)}return i}function x(t,e,n,r,s){return e instanceof o.Path2D&&t.push(new o.Path2D(r,e.closed)),e instanceof o&&t.push(o.fromPolygons(n)),null}t.exports={instantiatePolygon:l,instantiateVector:u,instantiateAsciiDxf:function(t,e){let n=[],r=null,s=[],i=[],c=[],g=null;for(let y of t.objstack)if(g=null,"type"in y){switch(y.type){case"dxf":break;case"layer":r=x(i,r,s,c),n.push(y);break;case"variable":r=x(i,r,s,c);break;case"3dface":g=l(y,n,e),null===r&&(r=new o);break;case"mesh":r=x(i,r,s,c),i.push(m(y,n,e));break;case"arc":r=x(i,r,s,c),i.push(f(y));break;case"circle":r=x(i,r,s,c),i.push(h(y));break;case"ellipse":r=x(i,r,s,c),i.push(d(y));break;case"line":r=x(i,r,s,c),i.push(a(y));break;case"polyline":null===r&&(r=w(y));break;case"vertex":g=u(y);break;case"seqend":r=x(i,r,s,c);break;case"lwpolyline":r=x(i,r,s,c),i.push(p(y))}g instanceof o.Polygon&&s.push(g),g instanceof o.Vector3D&&c.push(g),g instanceof o.Vector2D&&c.push(g)}return r=x(i,r,s,c),i}}},function(t,e,n){const{addTransformationMethodsToPrototype:o,addCenteringToPrototype:r}=n(36);let s=n(12),i=n(8);const{_CSGDEBUG:l,defaultResolution2D:a,defaultResolution3D:u,EPS:c,angleEPS:p,areaEPS:f,all:h,top:d,bottom:m,left:g,right:y,front:w,back:x,staticTag:b,getTag:v}=n(0);s._CSGDEBUG=l,s.defaultResolution2D=a,s.defaultResolution3D=u,s.EPS=c,s.angleEPS=p,s.areaEPS=f,s.all=h,s.top=d,s.bottom=m,s.left=g,s.right=y,s.front=w,s.back=x,s.staticTag=b,s.getTag=v,s.Vector2D=n(2),s.Vector3D=n(1),s.Vertex=n(5),i.Vertex=n(14),s.Plane=n(4),s.Polygon=n(3),s.Polygon2D=n(24),s.Line2D=n(20),s.Line3D=n(16),s.Path2D=n(18),s.OrthoNormalBasis=n(11),s.Matrix4x4=n(10),i.Side=n(17),s.Connector=n(13).Connector,s.ConnectorList=n(13).ConnectorList,s.Properties=n(21);const{circle:P,ellipse:_,rectangle:C,roundedRectangle:S}=n(52),{sphere:T,cube:M,roundedCube:z,cylinder:k,roundedCylinder:E,cylinderElliptic:D,polyhedron:A}=n(33);s.sphere=T,s.cube=M,s.roundedCube=z,s.cylinder=k,s.roundedCylinder=E,s.cylinderElliptic=D,s.polyhedron=A,i.circle=P,i.ellipse=_,i.rectangle=C,i.roundedRectangle=S;const{fromPolygons:V,fromCompactBinary:j,fromObject:I,fromSlices:O}=n(7);s.fromCompactBinary=j,s.fromObject=I,s.fromSlices=O,s.fromPolygons=V,s.toPointCloud=n(53).toPointCloud;const F=n(9);i.fromSides=F.fromSides,i.fromObject=F.fromObject,i.fromPoints=F.fromPoints,i.fromPointsNoCheck=F.fromPointsNoCheck,i.fromPath2=F.fromPath2,i.fromFakeCSG=F.fromFakeCSG,i.fromCompactBinary=F.fromCompactBinary;const B=n(15);o(s.prototype),o(s.Vector2D.prototype),o(s.Vector3D.prototype),o(s.Vertex.prototype),o(s.Plane.prototype),o(s.Polygon.prototype),o(s.Line2D.prototype),o(s.Line3D.prototype),o(s.Path2D.prototype),o(s.OrthoNormalBasis.prototype),o(s.Connector.prototype),o(i.prototype),o(i.Side.prototype),o(i.Vertex.prototype),s.parseOptionAs2DVector=B.parseOptionAs3DVector,s.parseOptionAs3DVector=B.parseOptionAs3DVector,s.parseOptionAs3DVectorList=B.parseOptionAs3DVectorList,s.parseOptionAsBool=B.parseOptionAsBool,s.parseOptionAsFloat=B.parseOptionAsFloat,s.parseOptionAsInt=B.parseOptionAsInt,s.Polygon2D.prototype=i.prototype;const{isCAG:G,isCSG:N}=n(6),$=Object.assign({},{CSG:s,CAG:i},B,{isCAG:G,isCSG:N});t.exports=$},function(t,e,n){const o=n(8),{fromPoints:r}=n(9);function s(t){const e=r(t);this.sides=e.sides}s.prototype=o.prototype,t.exports=s},function(t,e,n){const{areaEPS:o}=n(0),{linesIntersect:r}=n(38),s=function(t,e){let n=null,o=null,r=!1;return t.sides.forEach(t=>{n=t.vertex0.pos,o=t.vertex1.pos,s.c1(e,n,o)&&s.c2(e,n,o)&&(r=!r)}),r};s.c1=(t,e,n)=>e.y>t.y!=n.y>t.y,s.c2=(t,e,n)=>t.x<(n.x-e.x)*(t.y-e.y)/(n.y-e.y)+e.x;t.exports={isCAGValid:function(t){let e=[];t.isSelfIntersecting(!0)&&e.push("Self intersects");let n={};t.sides.map((function(t){function e(t){let e=t.x+" "+t.y;e in n||(n[e]=0),n[e]++}e(t.vertex0.pos),e(t.vertex1.pos)}));for(let t in n){let o=n[t];1&o&&e.push("Uneven number of sides ("+o+") for point "+t)}let r=t.area();if(r<o&&e.push("Area is "+r),e.length>0){let t="";throw e.map((function(e){t+=e+"\n"})),new Error(t)}},isSelfIntersecting:function(t,e){let n=t.sides.length;for(let o=0;o<n;o++){let s=t.sides[o];for(let i=o+1;i<n;i++){let n=t.sides[i];if(r(s.vertex0.pos,s.vertex1.pos,n.vertex0.pos,n.vertex1.pos))return e&&(console.log("side "+o+": "+s),console.log("side "+i+": "+n)),!0}}return!1},hasPointInside:s,contains:function(t,e){for(let n=0,o=e.sides.length;n<o;n++)if(!s(t,e.sides[n].vertex0.pos))return!1;return!0}}},function(t,e,n){const{EPS:o}=n(0),r=n(27),s=n(40),{fromPolygons:i}=n(7),{fromSides:l}=n(9),a=function(t,e){if(t.isCanonicalized)return t;{const e=new r;let n=c(e,t);return n.isCanonicalized=!0,n.isRetesselated=t.isRetesselated,n.properties=t.properties,n}},u=function(t,e){if(t.isCanonicalized)return t;{let e=new s,n=p(e,t);return n.isCanonicalized=!0,n}},c=function(t,e){let n=t,o=[];return e.polygons.forEach((function(t){let e=n.getPolygon(t);e.vertices.length>=3&&o.push(e)})),i(o)},p=function(t,e){let n=t,r=e.sides.map((function(t){return n.getSide(t)})).filter((function(t){return t.length()>o}));return l(r)};t.exports=function(t,e){return t.isCanonicalized?t:"sides"in t?u(t,e):a(t,e)}},function(t,e,n){const{EPS:o}=n(0),r=n(3),s=n(28),i=function(){this.vertexfactory=new s(3,o),this.planefactory=new s(4,o),this.polygonsharedfactory={}};i.prototype={getPolygonShared:function(t){let e=t.getHash();return e in this.polygonsharedfactory?this.polygonsharedfactory[e]:(this.polygonsharedfactory[e]=t,t)},getVertex:function(t){let e=[t.pos._x,t.pos._y,t.pos._z];return this.vertexfactory.lookupOrCreate(e,(function(e){return t}))},getPlane:function(t){let e=[t.normal._x,t.normal._y,t.normal._z,t.w];return this.planefactory.lookupOrCreate(e,(function(e){return t}))},getPolygon:function(t){let e=this.getPlane(t.plane),n=this.getPolygonShared(t.shared),o=this,s=t.vertices.map((function(t){return o.getVertex(t)})),i=[];if(s.length>0){let t=s[s.length-1].getTag();s.forEach((function(e){let n=e.getTag();n!==t&&i.push(e),t=n}))}return i.length<3&&(i=[]),new r(i,n,e)}},t.exports=i},function(t,e){const n=function(t,e){this.lookuptable={},this.multiplier=1/e};n.prototype={lookupOrCreate:function(t,e){let n="",o=this.multiplier;if(t.forEach((function(t){let e=Math.round(t*o);n+=e+"/"})),n in this.lookuptable)return this.lookuptable[n];{let r=e(t),s=t.map((function(t){let e=Math.floor(t*o);return[e+"/",e+1+"/"]})),i=1<<t.length;for(let t=0;t<i;++t){let e=t;n="",s.forEach((function(t){n+=t[1&e],e>>=1})),this.lookuptable[n]=r}return r}}},t.exports=n},function(t,e,n){const o=n(27),r=n(41),{fromPolygons:s}=n(7);t.exports=function(t){if(t.isRetesselated)return t;{let e={},n=t.isCanonicalized,i=new o;t.polygons.map((function(t){let o=t.plane,r=t.shared;n||(o=i.getPlane(o),r=i.getPolygonShared(r));let s=o.getTag()+"/"+r.getTag();s in e?e[s].push(t):e[s]=[t]}));let l=[];for(let t in e){let n=e[t];if(n.length<2)l=l.concat(n);else{let t=[];r(n,t),l=l.concat(t)}}let a=s(l);return a.isRetesselated=!0,a.properties=t.properties,a}}},function(t,e,n){const o=n(10),r=n(1),{Connector:s}=n(13),{fromPoints:i}=n(9),l=n(2);t.exports={lieFlat:function(t){let e=t.getTransformationToFlatLying();return t.transform(e)},getTransformationToFlatLying:function(t){return t.getTransformationAndInverseTransformationToFlatLying()[0]},getTransformationAndInverseTransformationToFlatLying:function(t){if(0===t.polygons.length){let t=new o;return[t,t]}{let e=t.canonicalized(),n={};e.polygons.map((function(t){n[t.plane.getTag()]=t.plane}));let i,l,a=new r(1,0,0),u=new r(0,1,0),c=new r(0,0,1),p=new s([0,0,0],[0,0,-1],a),f=new s([0,0,0],[0,0,-1],u),h=!0,d=0,m=0;for(let t in n){let g,y,w=n[t],x=w.normal.times(w.w);if(w.normal.cross(a).length()>w.normal.cross(u).length()){let t=new s(x,w.normal,a);g=t.getTransformationTo(p,!1,0),y=p.getTransformationTo(t,!1,0)}else{let t=new s(x,w.normal,u);g=t.getTransformationTo(f,!1,0),y=f.getTransformationTo(t,!1,0)}let b=e.transform(g),v=-w.normal.dot(c),P=b.getBounds(),_=P[1].z-P[0].z,C=h;if(C||(_<d||_===d&&v>m)&&(C=!0),C){let t=new r([-.5*(P[1].x+P[0].x),-.5*(P[1].y+P[0].y),-P[0].z]);g=g.multiply(o.translation(t)),y=o.translation(t.negated()).multiply(y),d=_,m=v,i=g,l=y}h=!1}return[i,l]}},overCutInsideCorners:function(t,e){let n=t.canonicalized(),o={};n.sides.map((function(t){t.vertex0.getTag()in o||(o[t.vertex0.getTag()]={pos:t.vertex0.pos,from:[],to:[]}),o[t.vertex0.getTag()].to.push(t.vertex1.pos),t.vertex1.getTag()in o||(o[t.vertex1.getTag()]={pos:t.vertex1.pos,from:[],to:[]}),o[t.vertex1.getTag()].from.push(t.vertex0.pos)}));let r=[];for(let t in o){let n=o[t];if(1===n.from.length&&1===n.to.length){let t=n.from[0],o=n.pos,s=n.to[0],a=o.minus(t).unit(),u=s.minus(o).unit();if(a.cross(u)<.001){let t=u.angleRadians()-a.angleRadians()+Math.PI;t<0?t+=2*Math.PI:t>=2*Math.PI&&(t-=2*Math.PI);let n=u.minus(a).unit(),s=30/180*Math.PI,c=e/Math.cos(s/2),p=o.plus(n.times(c)),f=t+n.angleRadians(),h=2*(Math.PI-t),d=2*Math.ceil(h/s/2),m=[p];for(let t=0;t<=d;t++){let e=f+t/d*h,n=l.fromAngleRadians(e).times(c).plus(p);m.push(n)}r.push(i(m))}}}return n.subtract(r)}}},function(t,e,n){const o=n(46);t.exports=function(t,e){t=Object.assign({},{axes:[!0,!0,!0],center:[0,0,0]},t);const{axes:n,center:r}=t,s=(e=o(e)).map((function(t){let e=t.getBounds(),o=[0,0,0];return n[0]&&(o[0]=r[0]-(e[0].x+(e[1].x-e[0].x)/2)),n[1]&&(o[1]=r[1]-(e[0].y+(e[1].y-e[0].y)/2)),n[2]&&(o[2]=r[2]-(e[0].z+(e[1].y-e[0].y)/2)),t.translate(o)}));return 1===s.length?s[0]:s}},function(t,e,n){const{EPS:o,angleEPS:r}=n(0),s=n(5),i=n(2),l=n(3),{fnNumberSort:a,isCSG:u}=n(6),{fromPoints:c,fromPointsNoCheck:p}=n(9),f=function(t,e,s){const l=n(8);(s=s||8)<4&&(s=4);let a=[],u={};t.canonicalized().sides.map((function(t){let n=t.vertex1.pos.minus(t.vertex0.pos),r=n.length();if(r>o){n=n.times(1/r);let o=n.normal().times(e),s=[t.vertex1.pos.plus(o),t.vertex1.pos.minus(o),t.vertex0.pos.minus(o),t.vertex0.pos.plus(o)],i=c(s);a.push(i);for(let e=0;e<2;e++){let n=0===e?t.vertex0.pos:t.vertex1.pos,o=0===e?t.vertex1.pos:t.vertex0.pos,r=n.x+" "+n.y;r in u||(u[r]=[]),u[r].push({p1:n,p2:o})}}}));for(let t in u){let n,o,l=u[t],c=l[0].p1;if(2===l.length){let t=l[0].p2,e=l[1].p2;if(n=t.minus(c).angleDegrees(),o=e.minus(c).angleDegrees(),o<n&&(o+=360),o>=n+360&&(o-=360),o<n+180){let t=o;o=n+360,n=t}n+=90,o-=90}else n=0,o=360;let f=o>n+359.999;if(f&&(n=0,o=360),o>n+r){let t=[];f||t.push(c);let r=Math.round(s*(o-n)/360);r<1&&(r=1);for(let s=0;s<=r;s++){let l=n+s/r*(o-n);s===r&&(l=o);let a=c.plus(i.fromAngleDegrees(l).times(e));(!f||s>0)&&t.push(a)}let l=p(t);a.push(l)}}let f=new l;return f=f.union(a),f},h=function(t,e,r,i){const u=n(12),{fromPolygons:c}=n(7);let p,f=t.reTesselated();p=i?f:new u,f.polygons.map((function(t){let n=t.plane.normal.unit().times(2*e),o=t.translate(n.times(-.5)).extrude(n);p=p.unionSub(o,!1,!1)}));let h={};f.polygons.map((function(t){let e=t.vertices.length,n=t.vertices[e-1],o=n.getTag();for(let r=0;r<e;r++){let e,s,i=t.vertices[r],l=i.getTag();e=l<o?l+"-"+o:o+"-"+l,e in h?s=h[e]:(s={v1:n,v2:i,planenormals:[]},h[e]=s),s.planenormals.push(t.plane.normal),o=l,n=i}}));for(let t in h){let n=h[t],i=n.v1.pos,u=n.v2.pos,f=u.minus(i).unit(),d=n.planenormals[0].unit(),m=d.cross(f),g=[];for(let t=0;t<r;t++)g.push(t*Math.PI*2/r);for(let t=0,e=n.planenormals.length;t<e;t++){let e=n.planenormals[t],o=m.dot(e),r=d.dot(e),s=Math.atan2(o,r);s<0&&(s+=2*Math.PI),g.push(s),s=Math.atan2(-o,-r),s<0&&(s+=2*Math.PI),g.push(s)}g=g.sort(a);let y,w,x=g.length,b=[],v=[],P=[];for(let t=-1;t<x;t++){let n=g[t<0?t+x:t],r=Math.sin(n),a=Math.cos(n),c=d.times(a*e).plus(m.times(r*e)),p=i.plus(c),f=u.plus(c),h=!1;if(t>=0&&p.distanceTo(y)<o&&(h=!0),!h){if(t>=0){b.push(new s(p)),v.push(new s(f));let t=[new s(w),new s(f),new s(p),new s(y)],e=new l(t);P.push(e)}y=p,w=f}}v.reverse(),P.push(new l(b)),P.push(new l(v));let _=c(P);p=p.unionSub(_,!1,!1)}let d={};f.polygons.map((function(t){t.vertices.map((function(e){let n,o=e.getTag();o in d?n=d[o]:(n={pos:e.pos,normals:[]},d[o]=n),n.normals.push(t.plane.normal)}))}));for(let t in d){let n=d[t],o=n.normals[0].unit(),s=null,i=0;for(let t=1;t<n.normals.length;t++){let e=n.normals[t].unit(),r=o.cross(e).length();r>.05&&r>i&&(i=r,s=e)}s||(s=o.randomNonParallelVector());let l=o.cross(s).unit(),a=l.cross(o),c=u.sphere({center:n.pos,radius:e,resolution:r,axes:[o,l,a]});p=p.unionSub(c,!1,!1)}return p};t.exports={expand:function(t,e,n){let o;return u(t)?(o=t.union(h(t,e,n)),o=o.reTesselated(),o.properties=t.properties):o=t.union(f(t,e,n)),o},contract:function(t,e,n){let o;return u(t)?(o=t.subtract(h(t,e,n)),o=o.reTesselated(),o.properties=t.properties):o=t.subtract(f(t,e,n)),o},expandedShellOfCAG:f,expandedShellOfCCSG:h}},function(t,e,n){const{parseOption:o,parseOptionAs3DVector:r,parseOptionAs2DVector:s,parseOptionAs3DVectorList:i,parseOptionAsFloat:l,parseOptionAsInt:a}=n(15),{defaultResolution3D:u,defaultResolution2D:c,EPS:p}=n(0),f=n(1),h=n(5),d=n(3),{Connector:m}=n(13),g=n(21),{fromPolygons:y}=n(7),w=function(t){let e,n,o,s=r(t=t||{},"center",[0,0,0]),i=l(t,"radius",1),c=a(t,"resolution",u);"axes"in t?(e=t.axes[0].unit().times(i),n=t.axes[1].unit().times(i),o=t.axes[2].unit().times(i)):(e=new f([1,0,0]).times(i),n=new f([0,-1,0]).times(i),o=new f([0,0,1]).times(i)),c<4&&(c=4);let p,m=Math.round(c/4),w=[];for(let t=0;t<=c;t++){let r=2*Math.PI*t/c,i=e.times(Math.cos(r)).plus(n.times(Math.sin(r)));if(t>0){let t,e,n=[];for(let r=0;r<=m;r++){let l=.5*Math.PI*r/m,a=Math.cos(l),u=Math.sin(l);r>0&&(n=[],n.push(new h(s.plus(p.times(t).minus(o.times(e))))),n.push(new h(s.plus(i.times(t).minus(o.times(e))))),r<m&&n.push(new h(s.plus(i.times(a).minus(o.times(u))))),n.push(new h(s.plus(p.times(a).minus(o.times(u))))),w.push(new d(n)),n=[],n.push(new h(s.plus(p.times(t).plus(o.times(e))))),n.push(new h(s.plus(i.times(t).plus(o.times(e))))),r<m&&n.push(new h(s.plus(i.times(a).plus(o.times(u))))),n.push(new h(s.plus(p.times(a).plus(o.times(u))))),n.reverse(),w.push(new d(n))),t=a,e=u}}p=i}let x=y(w);return x.properties.sphere=new g,x.properties.sphere.center=new f(s),x.properties.sphere.facepoint=s.plus(e),x};t.exports={cube:function(t){let e,n,o,s;if("corner1"in(t=t||{})||"corner2"in t){if("center"in t||"radius"in t)throw new Error("cube: should either give a radius and center parameter, or a corner1 and corner2 parameter");o=r(t,"corner1",[0,0,0]),s=r(t,"corner2",[1,1,1]),e=o.plus(s).times(.5),n=s.minus(o).times(.5)}else e=r(t,"center",[0,0,0]),n=r(t,"radius",[1,1,1]);n=n.abs();let i=y([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map((function(t){let o=t[0].map((function(t){let o=new f(e.x+n.x*(2*!!(1&t)-1),e.y+n.y*(2*!!(2&t)-1),e.z+n.z*(2*!!(4&t)-1));return new h(o)}));return new d(o,null)})));return i.properties.cube=new g,i.properties.cube.center=new f(e),i.properties.cube.facecenters=[new m(new f([n.x,0,0]).plus(e),[1,0,0],[0,0,1]),new m(new f([-n.x,0,0]).plus(e),[-1,0,0],[0,0,1]),new m(new f([0,n.y,0]).plus(e),[0,1,0],[0,0,1]),new m(new f([0,-n.y,0]).plus(e),[0,-1,0],[0,0,1]),new m(new f([0,0,n.z]).plus(e),[0,0,1],[1,0,0]),new m(new f([0,0,-n.z]).plus(e),[0,0,-1],[1,0,0])],i},sphere:w,roundedCube:function(t){let e,n,o,s;if("corner1"in(t=t||{})||"corner2"in t){if("center"in t||"radius"in t)throw new Error("roundedCube: should either give a radius and center parameter, or a corner1 and corner2 parameter");o=r(t,"corner1",[0,0,0]),s=r(t,"corner2",[1,1,1]),e=o.plus(s).times(.5),n=s.minus(o).times(.5)}else e=r(t,"center",[0,0,0]),n=r(t,"radius",[1,1,1]);n=n.abs();let i=a(t,"resolution",u);i<4&&(i=4),i%2==1&&i<8&&(i=8);let l=r(t,"roundradius",[.2,.2,.2]);l=f.Create(Math.max(l.x,.01),Math.max(l.y,.01),Math.max(l.z,.01));let c=n.minus(l);if(c.x<0||c.y<0||c.z<0)throw new Error("roundradius <= radius!");let d=w({radius:1,resolution:i});return d=d.scale(l),c.x>p&&(d=d.stretchAtPlane([1,0,0],[0,0,0],2*c.x)),c.y>p&&(d=d.stretchAtPlane([0,1,0],[0,0,0],2*c.y)),c.z>p&&(d=d.stretchAtPlane([0,0,1],[0,0,0],2*c.z)),d=d.translate([-c.x+e.x,-c.y+e.y,-c.z+e.z]),d=d.reTesselated(),d.properties.roundedCube=new g,d.properties.roundedCube.center=new h(e),d.properties.roundedCube.facecenters=[new m(new f([n.x,0,0]).plus(e),[1,0,0],[0,0,1]),new m(new f([-n.x,0,0]).plus(e),[-1,0,0],[0,0,1]),new m(new f([0,n.y,0]).plus(e),[0,1,0],[0,0,1]),new m(new f([0,-n.y,0]).plus(e),[0,-1,0],[0,0,1]),new m(new f([0,0,n.z]).plus(e),[0,0,1],[1,0,0]),new m(new f([0,0,-n.z]).plus(e),[0,0,-1],[1,0,0])],d},cylinder:function(t){let e=r(t,"start",[0,-1,0]),n=r(t,"end",[0,1,0]),o=l(t,"radius",1),s=l(t,"radiusEnd",o),i=l(t,"radiusStart",o),u=l(t,"sectorAngle",360);if(u=u>360?u%360:u,s<0||i<0)throw new Error("Radius should be non-negative");if(0===s&&0===i)throw new Error("Either radiusStart or radiusEnd should be positive");let p=a(t,"resolution",c),f=n.minus(e),w=f.unit(),x=w.randomNonParallelVector().unit(),b=x.cross(w).unit(),v=new h(e),P=new h(n),_=[];function C(t,n,o){let r=n*Math.PI*u/180,s=x.times(Math.cos(r)).plus(b.times(Math.sin(r))),i=e.plus(f.times(t)).plus(s.times(o));return new h(i)}if(u>0){for(let t=0;t<p;t++){let e=t/p,n=(t+1)/p;s===i?(_.push(new d([v,C(0,e,s),C(0,n,s)])),_.push(new d([C(0,n,s),C(0,e,s),C(1,e,s),C(1,n,s)])),_.push(new d([P,C(1,n,s),C(1,e,s)]))):(i>0&&(_.push(new d([v,C(0,e,i),C(0,n,i)])),_.push(new d([C(0,e,i),C(1,e,s),C(0,n,i)]))),s>0&&(_.push(new d([P,C(1,n,s),C(1,e,s)])),_.push(new d([C(1,e,s),C(1,n,s),C(0,n,i)]))))}u<360&&(_.push(new d([v,P,C(0,0,i)])),_.push(new d([C(0,0,i),P,C(1,0,s)])),_.push(new d([v,C(0,1,i),P])),_.push(new d([C(0,1,i),C(1,1,s),P])))}let S=y(_);S.properties.cylinder=new g,S.properties.cylinder.start=new m(e,w.negated(),x),S.properties.cylinder.end=new m(n,w,x);let T=e.plus(f.times(.5)),M=x.rotate(e,w,-u/2).times((i+s)/2),z=M.cross(w);return S.properties.cylinder.facepointH=new m(T.plus(M),M,w),S.properties.cylinder.facepointH90=new m(T.plus(z),z,w),S},roundedCylinder:function(t){let e,n=r(t,"start",[0,-1,0]),o=r(t,"end",[0,1,0]),s=l(t,"radius",1),i=o.minus(n);e=Math.abs(i.x)>Math.abs(i.y)?new f(0,1,0):new f(1,0,0);let c=r(t,"normal",e),x=a(t,"resolution",u);x<4&&(x=4);let b=[],v=Math.floor(.25*x);if(i.length()<p)return w({center:n,radius:s,resolution:x});let P,_=i.unit().times(s),C=_.cross(c).unit().times(s),S=C.cross(_).unit().times(s);for(let t=0;t<=x;t++){let e=2*Math.PI*t/x,r=C.times(Math.cos(e)).plus(S.times(Math.sin(e)));if(t>0){let t,e,s=[];s.push(new h(n.plus(r))),s.push(new h(n.plus(P))),s.push(new h(o.plus(P))),s.push(new h(o.plus(r))),b.push(new d(s));for(let i=0;i<=v;i++){let l=.5*Math.PI*i/v,a=Math.cos(l),u=Math.sin(l);i>0&&(s=[],s.push(new h(n.plus(P.times(t).minus(_.times(e))))),s.push(new h(n.plus(r.times(t).minus(_.times(e))))),i<v&&s.push(new h(n.plus(r.times(a).minus(_.times(u))))),s.push(new h(n.plus(P.times(a).minus(_.times(u))))),b.push(new d(s)),s=[],s.push(new h(o.plus(P.times(t).plus(_.times(e))))),s.push(new h(o.plus(r.times(t).plus(_.times(e))))),i<v&&s.push(new h(o.plus(r.times(a).plus(_.times(u))))),s.push(new h(o.plus(P.times(a).plus(_.times(u))))),s.reverse(),b.push(new d(s))),t=a,e=u}}P=r}let T=y(b),M=_.unit(),z=C.unit();return T.properties.roundedCylinder=new g,T.properties.roundedCylinder.start=new m(n,M.negated(),z),T.properties.roundedCylinder.end=new m(o,M,z),T.properties.roundedCylinder.facepoint=n.plus(C),T},cylinderElliptic:function(t){let e=r(t,"start",[0,-1,0]),n=r(t,"end",[0,1,0]),o=s(t,"radius",[1,1]),i=s(t,"radiusEnd",o),l=s(t,"radiusStart",o);if(i._x<0||l._x<0||i._y<0||l._y<0)throw new Error("Radius should be non-negative");if(!(0!==i._x&&0!==i._y||0!==l._x&&0!==l._y))throw new Error("Either radiusStart or radiusEnd should be positive");let u=a(t,"resolution",c),p=n.minus(e),f=p.unit(),w=f.randomNonParallelVector().unit(),x=w.cross(f).unit(),b=new h(e),v=new h(n),P=[];function _(t,n,o){let r=n*Math.PI*2,s=w.times(o._x*Math.cos(r)).plus(x.times(o._y*Math.sin(r))),i=e.plus(p.times(t)).plus(s);return new h(i)}for(let t=0;t<u;t++){let e=t/u,n=(t+1)/u;i._x===l._x&&i._y===l._y?(P.push(new d([b,_(0,e,i),_(0,n,i)])),P.push(new d([_(0,n,i),_(0,e,i),_(1,e,i),_(1,n,i)])),P.push(new d([v,_(1,n,i),_(1,e,i)]))):(l._x>0&&(P.push(new d([b,_(0,e,l),_(0,n,l)])),P.push(new d([_(0,e,l),_(1,e,i),_(0,n,l)]))),i._x>0&&(P.push(new d([v,_(1,n,i),_(1,e,i)])),P.push(new d([_(1,e,i),_(1,n,i),_(0,n,l)]))))}let C=y(P);return C.properties.cylinder=new g,C.properties.cylinder.start=new m(e,f.negated(),w),C.properties.cylinder.end=new m(n,f,w),C.properties.cylinder.facepoint=e.plus(w.times(l)),C},polyhedron:function(t){if("points"in(t=t||{})!="faces"in t)throw new Error("polyhedron needs 'points' and 'faces' arrays");let e=i(t,"points",[[1,1,0],[1,-1,0],[-1,-1,0],[-1,1,0],[0,0,1]]).map((function(t){return new h(t)})),n=o(t,"faces",[[0,1,4],[1,2,4],[2,3,4],[3,0,4],[1,0,3],[2,1,3]]);n.forEach((function(t){t.reverse()}));let r=n.map((function(t){return new d(t.map((function(t){return e[t]})))}));return y(r).reTesselated()}}},function(t,e,n){"use strict";n.r(e);const{colorIndex:o,BYLAYER:r,getTLA:s}=n(19),i=n(35),{instantiateAsciiDxf:l}=n(22),a=n(54);function u(t,e){if(!0===t.options.strict)throw e;console.log(`error: line ${e.line}, column ${e.column}, bad character [${e.c}]`)}function c(t,e){}function p(t,e){}function f(t,e,n){let o=null;switch(n){case"LAYER":o={type:"layer"},o[s(48)]=1,o[s(60)]=0,o[s(67)]=0,t.objstack.push(o);break;case"LINE":o={type:"line"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=0,t.objstack.push(o);break;case"LWPOLYLINE":o={type:"lwpolyline"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(38)]=0,o[s(39)]=0,o[s(43)]=0,o[s(70)]=0,o[s(90)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=1,t.objstack.push(o);break;case"MESH":o={type:"mesh"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(91)]=0,o[s(92)]=0,o[s(93)]=0,o[s(94)]=0,o[s(95)]=0,o.state=0,t.objstack.push(o);break;case"POLYLINE":o={type:"polyline"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(10)]=0,o[s(20)]=0,o[s(30)]=0,o[s(39)]=0,o[s(40)]=0,o[s(41)]=0,o[s(70)]=0,o[s(71)]=0,o[s(72)]=0,o[s(73)]=0,o[s(74)]=0,o[s(75)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=1,t.objstack.push(o);break;case"ARC":o={type:"arc"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(39)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=1,t.objstack.push(o);break;case"CIRCLE":o={type:"circle"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(39)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=1,t.objstack.push(o);break;case"ELLIPSE":o={type:"ellipse"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(210)]=0,o[s(220)]=0,o[s(230)]=1,t.objstack.push(o);break;case"VERTEX":o={type:"vertex"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(10)]=0,o[s(20)]=0,o[s(30)]=0,o[s(40)]=0,o[s(41)]=0,o[s(42)]=0,o[s(70)]=0,o[s(71)]=0,o[s(72)]=0,o[s(73)]=0,o[s(74)]=0,t.objstack.push(o);break;case"3DFACE":o={type:"3dface"},o[s(48)]=1,o[s(60)]=0,o[s(62)]=r,o[s(67)]=0,o[s(70)]=0,t.objstack.push(o);break;case"SEQEND":o={type:"seqend"},t.objstack.push(o);break;default:o={},t.objstack.push(o)}}function h(t,e,n){let o={type:"variable",name:n};t.objstack.push(o)}function d(t,e,n){let o=t.objstack.pop();"type"in o&&(o[s(e)]=parseFloat(n)),t.objstack.push(o)}function m(t,e,n){let o=t.objstack.pop();"type"in o&&(o[s(e)]=parseFloat(n)),t.objstack.push(o)}function g(t,e,n){let o=t.objstack.pop();"type"in o&&("lwpolyline"===o.type?(void 0===o.pptxs&&(o.pptxs=[],o.bulgs=[]),o.pptxs.push(parseFloat(n)),o.bulgs.push(0)):"mesh"===o.type?(void 0===o.pptxs&&(o.pptxs=[]),o.pptxs.push(parseFloat(n))):o[s(e)]=parseFloat(n)),t.objstack.push(o)}function y(t,e,n){let o=t.objstack.pop();"type"in o&&("lwpolyline"===o.type||"mesh"===o.type?(void 0===o.pptys&&(o.pptys=[]),o.pptys.push(parseFloat(n))):o[s(e)]=parseFloat(n)),t.objstack.push(o)}function w(t,e,n){let o=t.objstack.pop();"type"in o&&("mesh"===o.type?(void 0===o.pptzs&&(o.pptzs=[]),o.pptzs.push(parseFloat(n))):o[s(e)]=parseFloat(n)),t.objstack.push(o)}function x(t,e,n){let o=t.objstack.pop();if("type"in o)if("lwpolyline"===o.type){let t=o.bulgs;if(void 0!==t){o.pptxs.length===t.length&&(t[t.length-1]=parseFloat(n))}}else o[s(e)]=parseFloat(n);t.objstack.push(o)}function b(t,e,n){let o=t.objstack.pop();if("type"in o)if("mesh"===o.type){let t=o.state;switch(e){case 91:o[s(e)]=parseFloat(n),o.state=1;break;case 92:1===t?(o.vlen=parseFloat(n),o.state=2):(o.plen=parseFloat(n),o.state=6);break;case 93:o[s(e)]=parseFloat(n),o.state=3;break;case 94:o[s(e)]=parseFloat(n),o.state=4;break;case 95:o[s(e)]=parseFloat(n),o.state=5;break;default:o.state=7}}else o[s(e)]=parseFloat(n);t.objstack.push(o)}function v(t,e,n){let o=t.objstack.pop();if("type"in o)if("mesh"===o.type){switch(o.state){case 3:void 0===o.fvals&&(o.fvals=[]),o.fvals.push(parseFloat(n));break;case 4:void 0===o.evals&&(o.evals=[]),o.evals.push(parseFloat(n))}}else o[s(e)]=parseFloat(n);t.objstack.push(o)}function P(t,e,n){let o=t.objstack.pop();"type"in o&&(o[s(e)]=n),t.objstack.push(o)}function _(t,e,n){let o=t.objstack.pop();"type"in o&&void 0===o[s(e)]&&(o[s(e)]=n),t.objstack.push(o)}function C(t,e){let n=i.reader(e);return n.on("error",u),n.on("start",c),n.on("end",p),n.absorb(0,f),n.absorb(1,P),n.absorb(2,_),n.absorb(3,_),n.absorb(6,P),n.absorb(7,P),n.absorb(8,P),n.absorb(9,h),n.absorb(10,g),n.absorb(11,m),n.absorb(12,m),n.absorb(13,m),n.absorb(20,y),n.absorb(21,m),n.absorb(22,m),n.absorb(23,m),n.absorb(30,w),n.absorb(31,m),n.absorb(32,m),n.absorb(33,m),n.absorb(39,m),n.absorb(40,m),n.absorb(41,m),n.absorb(42,x),n.absorb(50,m),n.absorb(51,m),n.absorb(62,d),n.absorb(70,d),n.absorb(71,d),n.absorb(72,d),n.absorb(73,d),n.absorb(74,d),n.absorb(75,d),n.absorb(90,v),n.absorb(91,b),n.absorb(92,b),n.absorb(93,b),n.absorb(94,b),n.absorb(95,b),n.absorb(210,d),n.absorb(220,d),n.absorb(230,d),n.objstack=[],n.objstack.push({type:"dxf"}),n.write(t).close(),n}e.default=function(t,e,n){const r={version:"0.0.1",output:"jscad",strict:!0,colorindex:o,dxf:{angdir:0,insunits:4,pfacevmax:4}};return"jscad"===(n=Object.assign({},r,n)).output?function(t,e,n){let o=C(t,n),r=`// Produced by JSCAD IO Library : DXF Deserialization (${n.version})\n\n`;return r+=a(o,n),r}(t,0,n):function(t,e,n){let o=C(t,n);return l(o,n)}(t,0,n)}},function(t,e,n){!function(t){function e(t){this.options=t||{},this.trackPosition=!1!==this.options.track,this.trackPosition&&(this.line=this.column=this.c=0)}function n(t,e){return t.trackPosition&&(e+=`\nLine: ${t.line}\nColumn: ${t.column}\nChar: ${t.c}`),e=new Error(e),t.error=e,r(t,"onerror",e)}function o(t){return r(t,"onend",t.data)}function r(t,e,n){var o=e.toString();return t[o]&&t[o](t,n),t}function s(t,e){e=e.trim(),null===t.group?(!function(t,e){var o=parseInt(e);isNaN(o)?(n(t,"Invalid group (int)"),t.group=null):t.group=o}(t,e),t.value=null):function(t,e){t.options.strict,t.value=e}(t,e),null!==t.group&&null!==t.value&&(!function(t,e,n){if(void 0!==t.absorbers){var o=t.absorbers.get(e);void 0!==o&&o(t,e,n)}}(t,t.group,t.value),t.group=null,t.value=null)}function i(t,e){return t&&t.length>e?t.charAt(e):""}t.reader=function(t){return new e(t)},t.STATES=["start","end","error"],e.prototype={on:function(t,e){this["on"+t]=e},absorb:function(t,e){void 0===this.absorbers&&(this.absorbers=new Map),this.absorbers.set(t,e)},write:function(t){return function(t,e){if(t.error)throw t.error;if(t.isclosed)return n(t,"Cannot write after close");if(function(t){r(t,"onstart",t.data)}(t),null===e)return o(t);t.group=null,t.value=null,t.error=null,t.position=0,t.line=0,t.column=0;var l=0,a="",u="";for(;null===t.error&&(a=i(e,l++));)t.trackPosition&&(t.position++,"\n"===a?(t.line++,t.column=0):t.column++),"\n"===a?(s(t,u),u=""):u+=a;o(t)}(this,t),this},close:function(){return this.isclosed=!0,this}}}(e)},function(t,e,n){const o=n(10),r=n(1),s=n(4);t.exports={addTransformationMethodsToPrototype:function(t){t.mirrored=function(t){return this.transform(o.mirroring(t))},t.mirroredX=function(){let t=new s(r.Create(1,0,0),0);return this.mirrored(t)},t.mirroredY=function(){let t=new s(r.Create(0,1,0),0);return this.mirrored(t)},t.mirroredZ=function(){let t=new s(r.Create(0,0,1),0);return this.mirrored(t)},t.translate=function(t){return this.transform(o.translation(t))},t.scale=function(t){return this.transform(o.scaling(t))},t.rotateX=function(t){return this.transform(o.rotationX(t))},t.rotateY=function(t){return this.transform(o.rotationY(t))},t.rotateZ=function(t){return this.transform(o.rotationZ(t))},t.rotate=function(t,e,n){return this.transform(o.rotation(t,e,n))},t.rotateEulerAngles=function(t,e,n,s){s=s||[0,0,0];let i=o.rotationZ(t),l=o.rotationX(e),a=o.rotationZ(n),u=o.translation(new r(s));return this.transform(a.multiply(l).multiply(i).multiply(u))}},addCenteringToPrototype:function(t,e){t.center=function(t){(t=Array.prototype.map.call(arguments,(function(t){return t}))).length||(t=e.slice());let n=this.getBounds();return this.translate(e.map((function(e){return t.indexOf(e)>-1?-(n[0][e]+n[1][e])/2:0})))}}}},function(t,e,n){const{_CSGDEBUG:o,EPS:r}=n(0),s=n(5),i=n(3);const l=function(){this.parent=null,this.children=[],this.polygon=null,this.removed=!1};l.prototype={addPolygons:function(t){if(!this.isRootNode())throw new Error("Assertion failed");let e=this;t.map((function(t){e.addChild(t)}))},remove:function(){if(!this.removed){if(this.removed=!0,o){if(this.isRootNode())throw new Error("Assertion failed");if(this.children.length)throw new Error("Assertion failed")}let t=this.parent.children,e=t.indexOf(this);if(e<0)throw new Error("Assertion failed");t.splice(e,1),this.parent.recursivelyInvalidatePolygon()}},isRemoved:function(){return this.removed},isRootNode:function(){return!this.parent},invert:function(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()},getPolygon:function(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon},getPolygons:function(t){let e,n,o,r,s=[this],i=[s];for(e=0;e<i.length;++e)for(s=i[e],n=0,o=s.length;n<o;n++)r=s[n],r.polygon?t.push(r.polygon):i.push(r.children)},splitByPlane:function(t,e,n,o,r){if(this.children.length){let s,i,l,a,u,c=[this.children];for(s=0;s<c.length;s++)for(u=c[s],i=0,l=u.length;i<l;i++)a=u[i],a.children.length?c.push(a.children):a._splitByPlane(t,e,n,o,r)}else this._splitByPlane(t,e,n,o,r)},_splitByPlane:function(t,e,n,o,l){let a=this.polygon;if(a){let u=a.boundingSphere(),c=u[1]+r,p=t.normal,f=u[0],h=p.dot(f)-t.w;if(h>c)o.push(this);else if(h<-c)l.push(this);else{let u=function(t,e){let n={type:null,front:null,back:null},o=t.normal,l=e.vertices,a=l.length;if(e.plane.equals(t))n.type=0;else{let u=t.w,c=!1,p=!1,f=[],h=-r;for(let t=0;t<a;t++){let e=o.dot(l[t].pos)-u,n=e<0;f.push(n),e>r&&(c=!0),e<h&&(p=!0)}if(c||p)if(p)if(c){n.type=4;let o=[],u=[],c=f[0];for(let e=0;e<a;e++){let n=l[e],r=e+1;r>=a&&(r=0);let i=f[r];if(c===i)c?u.push(n):o.push(n);else{let e=n.pos,i=l[r].pos,a=t.splitLineBetweenPoints(e,i),p=new s(a);c?(u.push(n),u.push(p),o.push(p)):(o.push(n),o.push(p),u.push(p))}c=i}let p=r*r;if(u.length>=3){let t=u[u.length-1];for(let e=0;e<u.length;e++){let n=u[e];n.pos.distanceToSquared(t.pos)<p&&(u.splice(e,1),e--),t=n}}if(o.length>=3){let t=o[o.length-1];for(let e=0;e<o.length;e++){let n=o[e];n.pos.distanceToSquared(t.pos)<p&&(o.splice(e,1),e--),t=n}}o.length>=3&&(n.front=new i(o,e.shared,e.plane)),u.length>=3&&(n.back=new i(u,e.shared,e.plane))}else n.type=3;else n.type=2;else{let t=o.dot(e.plane.normal);n.type=t>=0?0:1}}return n}(t,a);switch(u.type){case 0:e.push(this);break;case 1:n.push(this);break;case 2:o.push(this);break;case 3:l.push(this);break;case 4:if(u.front){let t=this.addChild(u.front);o.push(t)}if(u.back){let t=this.addChild(u.back);l.push(t)}}}}},addChild:function(t){let e=new l;return e.parent=this,e.polygon=t,this.children.push(e),e},invertSub:function(){let t,e,n,o,r=[this],s=[r];for(t=0;t<s.length;t++)for(r=s[t],e=0,n=r.length;e<n;e++)o=r[e],o.polygon&&(o.polygon=o.polygon.flipped()),s.push(o.children)},recursivelyInvalidatePolygon:function(){let t=this;for(;t.polygon;)t.polygon=null,t.parent&&(t=t.parent)}};const a=function(t){this.polygonTree=new l,this.rootnode=new u(null),t&&this.addPolygons(t)};a.prototype={invert:function(){this.polygonTree.invert(),this.rootnode.invert()},clipTo:function(t,e){e=!!e,this.rootnode.clipTo(t,e)},allPolygons:function(){let t=[];return this.polygonTree.getPolygons(t),t},addPolygons:function(t){let e=this,n=t.map((function(t){return e.polygonTree.addChild(t)}));this.rootnode.addPolygonTreeNodes(n)}};const u=function(t){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=t};u.prototype={invert:function(){let t,e=[this];for(let n=0;n<e.length;n++){t=e[n],t.plane&&(t.plane=t.plane.flipped()),t.front&&e.push(t.front),t.back&&e.push(t.back);let o=t.front;t.front=t.back,t.back=o}},clipPolygons:function(t,e){let n,o={node:this,polygontreenodes:t},r=[];do{if(n=o.node,t=o.polygontreenodes,n.plane){let o=[],s=[],i=e?o:s,l=n.plane,a=t.length;for(let e=0;e<a;e++){let n=t[e];n.isRemoved()||n.splitByPlane(l,i,o,s,o)}n.front&&s.length>0&&r.push({node:n.front,polygontreenodes:s});let u=o.length;if(n.back&&u>0)r.push({node:n.back,polygontreenodes:o});else for(let t=0;t<u;t++)o[t].remove()}o=r.pop()}while(void 0!==o)},clipTo:function(t,e){let n=this,o=[];do{n.polygontreenodes.length>0&&t.rootnode.clipPolygons(n.polygontreenodes,e),n.front&&o.push(n.front),n.back&&o.push(n.back),n=o.pop()}while(void 0!==n)},addPolygonTreeNodes:function(t){let e,n={node:this,polygontreenodes:t},o=[];do{if(e=n.node,0===(t=n.polygontreenodes).length){n=o.pop();continue}let r=e;if(!e.plane){let n=t[0].getPolygon().plane;e.plane=n}let s=[],i=[];for(let e=0,n=t.length;e<n;++e)t[e].splitByPlane(r.plane,r.polygontreenodes,i,s,i);s.length>0&&(e.front||(e.front=new u(e)),o.push({node:e.front,polygontreenodes:s})),i.length>0&&(e.back||(e.back=new u(e)),o.push({node:e.back,polygontreenodes:i})),n=o.pop()}while(void 0!==n)},getParentPlaneNormals:function(t,e){e>0&&this.parent&&(t.push(this.parent.plane.normal),this.parent.getParentPlaneNormals(t,e-1))}},t.exports=a},function(t,e,n){const{EPS:o}=n(0),{solve2Linear:r}=n(6);t.exports={linesIntersect:function(t,e,n,s){if(e.equals(n)||s.equals(t)){if(s.minus(n).unit().plus(e.minus(t).unit()).length()<o)return!0}else{let o=e.minus(t),i=s.minus(n);if(Math.abs(o.cross(i))<1e-9)return!1;let l=r(-o.x,i.x,-o.y,i.y,t.x-n.x,t.y-n.y);if(l[0]>1e-6&&l[0]<.999999&&l[1]>1e-5&&l[1]<.999999)return!0}return!1}}},function(t,e,n){const{isCAG:o}=n(6);t.exports={union:function(){let t={};const e={extrude2d:!1};let n,r=0,s=arguments;s[0].length&&(s=s[0]),"extrude2d"in s[0]&&(t=Object.assign({},e,s[0]),n=s[r++]),n=s[r++],"object"==typeof s[r]&&o(s[r])&&t.extrude2d&&(n=s[r].extrude({offset:[0,0,.1]}));for(;r<s.length;r++){let e=s[r];"object"==typeof s[r]&&o(s[r])&&t.extrude2d&&(e=s[r].extrude({offset:[0,0,.1]})),n=n.union(e)}return n},difference:function(){let t,e=0,n=arguments;for(n[0].length&&(n=n[0]),t=n[e++];e<n.length;e++)t=o(n[e])?t.subtract(n[e]):t.subtract(n[e].setColor(1,1,0));return t},intersection:function(){let t,e=0,n=arguments;for(n[0].length&&(n=n[0]),t=n[e++];e<n.length;e++)t=o(n[e])?t.intersect(n[e]):t.intersect(n[e].setColor(1,1,0));return t}}},function(t,e,n){const o=n(28),{EPS:r}=n(0),s=n(17),i=function(){this.vertexfactory=new o(2,r)};i.prototype={getVertex:function(t){let e=[t.pos._x,t.pos._y];return this.vertexfactory.lookupOrCreate(e,(function(e){return t}))},getSide:function(t){let e=this.getVertex(t.vertex0),n=this.getVertex(t.vertex1);return new s(e,n)}},t.exports=i},function(t,e,n){const{EPS:o}=n(0),r=n(11),{interpolateBetween2DPointsForY:s,insertSorted:i,fnNumberSort:l}=n(6),a=n(5),u=n(2),c=n(20),p=n(3);t.exports=function(t,e){let n=t.length;if(n>0){let f=t[0].plane,h=t[0].shared,d=new r(f),m=[],g=[],y={},w={},x={},b=1/o*10;for(let e=0;e<n;e++){let n=t[e],o=[],r=n.vertices.length,s=-1;if(r>0){let t,i,l;for(let a=0;a<r;a++){let r,c=d.to2D(n.vertices[a].pos),p=Math.floor(c.y*b);p in x?r=x[p]:p+1 in x?r=x[p+1]:p-1 in x?r=x[p-1]:(r=c.y,x[p]=c.y),c=u.Create(c.x,r),o.push(c);let f=c.y;(0===a||f<t)&&(t=f,s=a),(0===a||f>i)&&(i=f,l=a),f in w||(w[f]={}),w[f][e]=!0}t>=i?(o=[],r=0,s=-1):(t in y||(y[t]=[]),y[t].push(e))}o.reverse(),s=r-s-1,m.push(o),g.push(s)}let v=[];for(let t in w)v.push(t);v.sort(l);let P=[],_=[];for(let t=0;t<v.length;t++){let n,r=[],l=v[t],x=Number(l),b=w[l];for(let t=0;t<P.length;++t){let e=P[t],n=e.polygonindex;if(b[n]){let o=m[n],r=o.length,s=e.leftvertexindex,i=e.rightvertexindex;for(;;){let t=s+1;if(t>=r&&(t=0),o[t].y!==x)break;s=t}let l=i-1;if(l<0&&(l=r-1),o[l].y===x&&(i=l),s!==e.leftvertexindex&&s===i)P.splice(t,1),--t;else{e.leftvertexindex=s,e.rightvertexindex=i,e.topleft=o[s],e.topright=o[i];let t=s+1;t>=r&&(t=0),e.bottomleft=o[t];let n=i-1;n<0&&(n=r-1),e.bottomright=o[n]}}}if(t>=v.length-1)P=[],n=null;else{n=Number(v[t+1]);let e=.5*(x+n),o=y[l];for(let t in o){let n=o[t],r=m[n],l=r.length,a=g[n],u=a;for(;;){let t=u+1;if(t>=l&&(t=0),r[t].y!==x)break;if(t===a)break;u=t}let c=a;for(;;){let t=c-1;if(t<0&&(t=l-1),r[t].y!==x)break;if(t===u)break;c=t}let p=u+1;p>=l&&(p=0);let f=c-1;f<0&&(f=l-1);let h={polygonindex:n,leftvertexindex:u,rightvertexindex:c,topleft:r[u],topright:r[c],bottomleft:r[p],bottomright:r[f]};i(P,h,(function(t,n){let o=s(t.topleft,t.bottomleft,e),r=s(n.topleft,n.bottomleft,e);return o>r?1:o<r?-1:0}))}}for(let t in P){let e=P[t],i=(m[e.polygonindex].length,s(e.topleft,e.bottomleft,x)),l=u.Create(i,x);i=s(e.topright,e.bottomright,x);let a=u.Create(i,x);i=s(e.topleft,e.bottomleft,n);let p=u.Create(i,n);i=s(e.topright,e.bottomright,n);let f=u.Create(i,n),h={topleft:l,topright:a,bottomleft:p,bottomright:f,leftline:c.fromPoints(l,p),rightline:c.fromPoints(f,a)};if(r.length>0){let t=r[r.length-1],e=h.topleft.distanceTo(t.topright),n=h.bottomleft.distanceTo(t.bottomright);e<o&&n<o&&(h.topleft=t.topleft,h.leftline=t.leftline,h.bottomleft=t.bottomleft,r.splice(r.length-1,1))}r.push(h)}if(t>0){let t={},n={};for(let e=0;e<r.length;e++){let s=r[e];for(let e=0;e<_.length;e++)if(!n[e]){let r=_[e];if(r.bottomleft.distanceTo(s.topleft)<o&&r.bottomright.distanceTo(s.topright)<o){n[e]=!0;let i=s.leftline.direction().x-r.leftline.direction().x,l=s.rightline.direction().x-r.rightline.direction().x,a=Math.abs(i)<o,u=Math.abs(l)<o,c=u||l>=0;(a||i>=0)&&c&&(s.outpolygon=r.outpolygon,s.leftlinecontinues=a,s.rightlinecontinues=u,t[e]=!0);break}}}for(let n=0;n<_.length;n++)if(!t[n]){let t=_[n];t.outpolygon.rightpoints.push(t.bottomright),t.bottomright.distanceTo(t.bottomleft)>o&&t.outpolygon.leftpoints.push(t.bottomleft),t.outpolygon.leftpoints.reverse();let r=t.outpolygon.rightpoints.concat(t.outpolygon.leftpoints),s=[];r.map((function(t){let e=d.to3D(t),n=new a(e);s.push(n)}));let i=new p(s,h,f);e.push(i)}}for(let t=0;t<r.length;t++){let e=r[t];e.outpolygon?(e.leftlinecontinues||e.outpolygon.leftpoints.push(e.topleft),e.rightlinecontinues||e.outpolygon.rightpoints.push(e.topright)):(e.outpolygon={leftpoints:[],rightpoints:[]},e.outpolygon.leftpoints.push(e.topleft),e.topleft.distanceTo(e.topright)>o&&e.outpolygon.rightpoints.push(e.topright))}_=r}}}},function(t,e,n){const o=n(2);t.exports={area:function(t){let e=0;return t.sides.map((function(t){e+=t.vertex0.pos.cross(t.vertex1.pos)})),e*=.5,e},getBounds:function(t){let e;e=0===t.sides.length?new o(0,0):t.sides[0].vertex0.pos;let n=e;return t.sides.map((function(t){e=e.min(t.vertex0.pos),e=e.min(t.vertex1.pos),n=n.max(t.vertex0.pos),n=n.max(t.vertex1.pos)})),[e,n]}}},function(t,e,n){const{EPS:o,defaultResolution3D:r}=n(0),s=n(11),{parseOptionAs3DVector:i,parseOptionAsBool:l,parseOptionAsFloat:a,parseOptionAsInt:u}=n(15),c=n(1),p=n(10),f=n(18),{Connector:h}=n(13),{fromPolygons:d}=n(7),{cagToPointsArray:m,clamp:g,rightMultiply1x3VectorToArray:y,polygonFromPoints:w}=n(44),{fromPoints:x}=n(9),b=function(t,e,n,o){if(!(e instanceof s))throw new Error("extrudeInPlane: the first parameter should be a OrthoNormalBasis");let r=t.extrude({offset:[0,0,n]});l(o,"symmetrical",!1)&&(r=r.translate([0,0,-n/2]));let i=e.getInverseProjectionMatrix();return r=r.transform(i),r};t.exports={extrudeInOrthonormalBasis:b,extrudeInPlane:function(t,e,n,o,r){return b(t,s.GetCartesian(e,n),o,r)},extrude:function(t,e){const o=n(12);if(0===t.sides.length)return new o;let s=i(e,"offset",[0,0,1]),l=a(e,"twistangle",0),p=u(e,"twiststeps",r);if(0===s.z)throw new Error("offset cannot be orthogonal to Z axis");(0===l||p<1)&&(p=1);let f=c.Create(0,1,0),m=[];m=m.concat(t._toPlanePolygons({translation:[0,0,0],normalVector:f,flipped:!(s.z<0)})),m=m.concat(t._toPlanePolygons({translation:s,normalVector:f.rotateZ(l),flipped:s.z<0}));for(let e=0;e<p;e++){let n=new h(s.times(e/p),[0,0,s.z],f.rotateZ(e*l/p)),o=new h(s.times((e+1)/p),[0,0,s.z],f.rotateZ((e+1)*l/p));m=m.concat(t._toWallPolygons({toConnector1:n,toConnector2:o}))}return d(m)},linear_extrude:function(t,e){const{height:n,twist:o,slices:r,center:s}=Object.assign({},{height:1,slices:10,twist:0,center:!1},t);let i=e.extrude({offset:[0,0,n],twistangle:o,twiststeps:r});if(!0===s){const t=i.getBounds(),e=t[1].plus(t[0]).times(-.5);i=i.translate(e)}return i},rotate_extrude:function(t,e){const n={fn:32,startAngle:0,angle:360,overflow:"cap"};t=Object.assign({},n,t);let{fn:o,startAngle:r,angle:s,overflow:i}=t;if("cap"!==i)throw new Error("only capping of overflowing points is supported !");arguments.length<2&&(e=t);const l=s>0,a=l?g(r+s,0,360):g(r+s,-360,0),u=Math.max(Math.floor(Math.abs(a)/45),1,o),c=1e-5;let f=m(e);const h=f.filter(t=>t[0]<0),b=f.filter(t=>t[0]>=0),v=h.length>0&&b.length>0;v&&"cap"===i&&(h.length>b.length?f=f.map((function(t){return[Math.min(t[0],0),t[1]]})):b.length>=h.length&&(f=f.map((function(t){return[Math.max(t[0],0),t[1]]}))));let P=[];for(let t=1;t<u+1;t++){for(let e=0;e<f.length-1;e++){const n=f[e],o=f[e+1];let i=p.rotationZ((t-1)/u*s+r),a=p.rotationZ(t/u*s+r);const h=y(i,[n[0],0,n[1]]),d=y(a,[n[0],0,n[1]]),m=y(i,[o[0],0,o[1]]),g=y(a,[o[0],0,o[1]]);let x=!1;Math.abs(h[0]-d[0])<c&&Math.abs(m[1]-g[1])<c&&(x=!0),l?(P.push(w([h,m,g])),x||P.push(w([g,d,h]))):(x||P.push(w([h,d,g])),P.push(w([g,m,h])))}if(Math.abs(s)<360){const t=x(f),e=p.rotationX(90).multiply(p.rotationZ(-r)),n=t._toPlanePolygons({flipped:l}).map(t=>t.transform(e)),o=p.rotationX(90).multiply(p.rotationZ(-s-r)),i=t._toPlanePolygons({flipped:!l}).map(t=>t.transform(o));P=P.concat(n).concat(i)}}return d(P).reTesselated().canonicalized()},rotateExtrude:function(t,e){let n=a(e,"angle",360),s=u(e,"resolution",r);n=n>360?n%360:n;let i=[0,0,0],l=c.Create(0,1,0),p=[0,0,1],f=[],m=new h(i,l,p);if(n>0&&n<360){let e=new h(i,l.rotateZ(-n),p);f=f.concat(t._toPlanePolygons({toConnector:m,flipped:!0})),f=f.concat(t._toPlanePolygons({toConnector:e}))}let g,y=m,w=n/s;for(let e=w;e<=n+o;e+=w)g=new h(i,l.rotateZ(-e),p),f=f.concat(t._toWallPolygons({toConnector1:y,toConnector2:g})),y=g;return d(f).reTesselated()},rectangular_extrude:function(t,e){const{w:n,h:o,fn:r,closed:s,round:i}=Object.assign({},{w:1,h:1,fn:8,closed:!1,round:!0},e);return new f(t,s).rectangularExtrude(n,o,r,i)}}},function(t,e,n){const o=n(5),r=n(1),s=n(3);t.exports={cagToPointsArray:t=>{let e;return"sides"in t?(e=[],t.sides.forEach(t=>{e.push([t.vertex0.pos.x,t.vertex0.pos.y]),e.push([t.vertex1.pos.x,t.vertex1.pos.y])})):"points"in t&&(e=t.points.map(t=>[t.x,t.y])),e},clamp:function(t,e,n){return Math.min(Math.max(t,e),n)},rightMultiply1x3VectorToArray:(t,e)=>{const[n,o,r]=e;let s=n*t.elements[0]+o*t.elements[1]+r*t.elements[2]+1*t.elements[3],i=n*t.elements[4]+o*t.elements[5]+r*t.elements[6]+1*t.elements[7],l=n*t.elements[8]+o*t.elements[9]+r*t.elements[10]+1*t.elements[11],a=n*t.elements[12]+o*t.elements[13]+r*t.elements[14]+1*t.elements[15];if(1!==a){const t=1/a;s*=t,i*=t,l*=t}return[s,i,l]},polygonFromPoints:t=>{const e=t.map(t=>new o(new r(t)));return new s(e)}}},function(t,e,n){const o=n(18);t.exports=function(t){let e=t.canonicalized(),n={},r={};e.sides.map((function(t){let e=t.getTag();n[e]=t;let o=t.vertex0.getTag();o in r||(r[o]=[]),r[o].push(e)}));let s=[];for(;;){let t=null;for(let e in r){let n=r[e];t=n[0],n.splice(0,1),0===n.length&&delete r[e];break}if(null===t)break;let e=[],i=n[t],l=i.vertex0.getTag();for(;;){e.push(i.vertex0.pos);let t=i.vertex1.getTag();if(t===l)break;if(!(t in r))throw new Error("Area is not closed!");let o=r[t],s=-1;if(1===o.length)s=0;else{let t=null,e=i.direction().angleDegrees();for(let r=0;r<o.length;r++){let i=o[r],l=n[i].direction().angleDegrees()-e;l<-180&&(l+=360),l>=180&&(l-=360),(s<0||l>t)&&(s=r,t=l)}}let a=o[s];o.splice(s,1),0===o.length&&delete r[t],i=n[a]}e.length>0&&e.push(e.shift());let a=new o(e,!0);s.push(a)}return s}},function(t,e){t.exports=function(t){return t?t.constructor!==Array?[t]:t:[]}},function(t,e,n){const o=n(3),{fromPolygons:r}=n(7),{fnSortByIndex:s}=n(6),i=function(t,e,n,r){let i=e.vertices.slice(0),l=n.vertices.slice(0),a=n.shared||null;i[0].pos.equals(i[i.length-1].pos)||i.push(i[0]),l[0].pos.equals(l[l.length-1].pos)||l.push(l[0]),r&&(i=i.reverse(),l=l.reverse());let u,c=l.length-1,p=i.length-1,f=c-p,h=f>0,d=f<0,m=[];for(let t=Math.abs(f);t>0;t--)m.push({len:1/0,index:-1});if(d)for(let t=0;t<p;t++){u=i[t].pos.distanceToSquared(i[t+1].pos);for(let t=m.length-1;t>=0;t--)if(m[t].len>u){m[t].len=u,m.index=t;break}}else if(h)for(let t=0;t<c;t++){u=l[t].pos.distanceToSquared(l[t+1].pos);for(let t=m.length-1;t>=0;t--)if(m[t].len>u){m[t].len=u,m.index=t;break}}m.sort(s);let g,y,w,x=function(t,e,n,r){return new o([t,e,n],r)},b=i[0],v=l[0];for(let e=0,n=0,o=c+p;e+n<o;){if(m.length){if(h&&n===m[0].index){g=l[++n],t.push(x(g,v,b,a)),v=g,m.shift();continue}if(d&&e===m[0].index){g=i[++e],t.push(x(v,b,g,a)),b=g,m.shift();continue}}y=e<p?v.pos.distanceToSquared(i[e+1].pos):1/0,w=n<c?b.pos.distanceToSquared(l[n+1].pos):1/0,y<=w?(g=i[++e],t.push(x(v,b,g,a)),b=g):n<c&&(g=l[++n],t.push(x(g,v,b,a)),v=g)}return t};t.exports=function(t,e){let n,s=[],l=null,a=null,u=null,c=null,p=2,f=!1,h=null;if(e&&(f=Boolean(e.loop),e.numslices&&(p=e.numslices),e.callback&&(n=e.callback)),!n){let t=o.createFromPoints([[0,0,0],[1,0,0],[1,1,0],[0,1,0]]);n=function(e,n){return 0===e||1===e?t.translate([0,0,e]):null}}for(let e=0,r=p-1;e<=r;e++)if(l=n.call(t,e/r,e),l){if(!(l instanceof o))throw new Error("Polygon.solidFromSlices callback error: Polygon expected");l.checkIfConvex(),a?(null===h&&(h=a.plane.signedDistanceToPoint(l.vertices[0].pos)<0),i(s,a,l,h)):u=l,a=l}if(c=l,f){u.vertices.length===c.vertices.length&&u.vertices.every((function(t,e){return t.pos.equals(c.vertices[e].pos)}))||i(s,c,u,h)}else s.unshift(h?u:u.flipped()),s.push(h?c.flipped():c);return r(s)}},function(t,e,n){const{EPS:o}=n(0),r=n(3),s=n(4);function i(t,e,n,o,r,s){let i=o.getTag(),a=r.getTag();if(i===a)throw new Error("Assertion failed");let u=i+"/"+a;if(a+"/"+i in t)return l(t,e,n,r,o,null),null;let c={vertex0:o,vertex1:r,polygonindex:s};return u in t?t[u].push(c):t[u]=[c],i in e?e[i].push(u):e[i]=[u],a in n?n[a].push(u):n[a]=[u],u}function l(t,e,n,o,r,s){let i=o.getTag(),l=r.getTag(),a=i+"/"+l;if(!(a in t))throw new Error("Assertion failed");let u=-1,c=t[a];for(let t=0;t<c.length;t++){let e=c[t];if(e.vertex0===o&&(e.vertex1===r&&(null===s||e.polygonindex===s))){u=t;break}}if(u<0)throw new Error("Assertion failed");if(c.splice(u,1),0===c.length&&delete t[a],u=e[i].indexOf(a),u<0)throw new Error("Assertion failed");if(e[i].splice(u,1),0===e[i].length&&delete e[i],u=n[l].indexOf(a),u<0)throw new Error("Assertion failed");n[l].splice(u,1),0===n[l].length&&delete n[l]}t.exports=function(t,e){e=e.canonicalized();let n={};for(let t=0;t<e.polygons.length;t++){let o=e.polygons[t],r=o.vertices.length;if(r>=3){let e=o.vertices[0],s=e.getTag();for(let i=0;i<r;i++){let l=i+1;l===r&&(l=0);let a=o.vertices[l],u=a.getTag(),c=s+"/"+u,p=u+"/"+s;if(p in n){let t=n[p];t.splice(-1,1),0===t.length&&delete n[p]}else{let o={vertex0:e,vertex1:a,polygonindex:t};c in n?n[c].push(o):n[c]=[o]}e=a,s=u}}}let a={},u={},c={},p=!0;for(let t in n)p=!1,c[t]=!0,n[t].map((function(e){let n=e.vertex0.getTag(),o=e.vertex1.getTag();n in a?a[n].push(t):a[n]=[t],o in u?u[o].push(t):u[o]=[t]}));if(!p){let p=e.polygons.slice(0);for(;;){let t=!0;for(let e in n)t=!1,c[e]=!0;if(t)break;let e=!1;for(;;){let t=null;for(let e in c){t=e;break}if(null===t)break;let f=!0;if(t in n){let h=n[t];if(0===h.length)throw new Error("Assertion failed");let d=h[0];for(let t=0;t<2;t++){let h=0===t?d.vertex0:d.vertex1,m=0===t?d.vertex1:d.vertex0,g=h.getTag(),y=m.getTag(),w=[];0===t?g in u&&(w=u[g]):g in a&&(w=a[g]);for(let d=0;d<w.length;d++){let x=n[w[d]][0],b=0===t?x.vertex0:x.vertex1,v=0===t?x.vertex1:x.vertex0,P=b.getTag();if(v.getTag()!==g)throw new Error("Assertion failed");if(P===y){l(n,a,u,h,m,null),l(n,a,u,m,h,null),f=!1,t=2,e=!0;break}{let d=h.pos,g=m.pos,y=b.pos.minus(d),w=g.minus(d).dot(y)/y.dot(y);if(w>0&&w<1){if(d.plus(y.times(w)).distanceToSquared(g)<o*o){let o=x.polygonindex,h=p[o],d=x.vertex1.getTag(),g=-1;for(let t=0;t<h.vertices.length;t++)if(h.vertices[t].getTag()===d){g=t;break}if(g<0)throw new Error("Assertion failed");let y=h.vertices.slice(0);y.splice(g,0,m);let w=new r(y,h.shared);if(isNaN(w.plane.w)){let t=!1,e=function(e){w.vertices.forEach((function(n){t||e(n)}))};e((function(n){e((function(o){e((function(e){w.plane=s.fromPoints(n.pos,o.pos,e.pos),isNaN(w.plane.w)||(t=!0)}))}))}))}p[o]=w,l(n,a,u,x.vertex0,x.vertex1,o);let b=i(n,a,u,x.vertex0,m,o),v=i(n,a,u,m,x.vertex1,o);null!==b&&(c[b]=!0),null!==v&&(c[v]=!0),f=!1,t=2,e=!0;break}}}}}}f&&delete c[t]}if(!e)break}let f=t(p);f.properties=e.properties,f.isCanonicalized=!0,f.isRetesselated=!0,e=f}return e}},function(t,e,n){const o=n(1);t.exports={bounds:function(t){if(!t.cachedBoundingBox){let e=new o(0,0,0),n=new o(0,0,0),r=t.polygons,s=r.length;for(let t=0;t<s;t++){let o=r[t].boundingBox();0===t?(e=o[0],n=o[1]):(e=e.min(o[0]),n=n.max(o[1]))}t.cachedBoundingBox=[e,n]}return t.cachedBoundingBox},volume:function(t){let e=t.toTriangles().map((function(t){return t.getTetraFeatures(["volume"])}));console.log("volume",e)},area:function(t){let e=t.toTriangles().map((function(t){return t.getTetraFeatures(["area"])}));console.log("area",e)}}},function(t,e,n){const o=n(8),{EPS:r}=n(0);t.exports={projectToOrthoNormalBasis:function(t,e){let n=[];return t.polygons.filter((function(t){return t.plane.normal.minus(e.plane.normal).lengthSquared()<r*r})).map((function(t){let o=t.projectToOrthoNormalBasis(e);o.sides.length>0&&n.push(o)})),(new o).union(n)}}},function(t,e,n){const{EPS:o}=n(0),r=n(4),s=n(2),i=n(5),l=n(3),a=n(11);t.exports={sectionCut:function(t,e){let n=e.plane,s=e.plane.flipped();n=new r(n.normal,n.w),s=new r(s.normal,s.w+5*o);let i=t.cutByPlane(n);return i=i.cutByPlane(s),i.projectToOrthoNormalBasis(e)},cutByPlane:function(t,e){if(0===t.polygons.length){return new(n(12))}let o=e.normal.times(e.w),r=0;t.polygons.map((function(t){t.vertices.map((function(t){let e=t.pos.distanceToSquared(o);e>r&&(r=e)}))})),r=Math.sqrt(r),r*=1.01;let u=[],c=new a(e);u.push(new i(c.to3D(new s(r,-r)))),u.push(new i(c.to3D(new s(-r,-r)))),u.push(new i(c.to3D(new s(-r,r)))),u.push(new i(c.to3D(new s(r,r))));const p=new l(u,null,e.flipped()).extrude(e.normal.times(-r));let f=t.intersect(p);return f.properties=t.properties,f}}},function(t,e,n){n(8);const{parseOptionAs2DVector:o,parseOptionAsFloat:r,parseOptionAsInt:s}=n(15),{defaultResolution2D:i}=n(0),l=n(2),a=(n(14),n(18)),{fromCompactBinary:u,fromPoints:c,fromPath2:p,fromSides:f}=n(9),h=function(t){let e,n;if("corner1"in(t=t||{})||"corner2"in t){if("center"in t||"radius"in t)throw new Error("rectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter");let r=o(t,"corner1",[0,0]),s=o(t,"corner2",[1,1]);e=r.plus(s).times(.5),n=s.minus(r).times(.5)}else e=o(t,"center",[0,0]),n=o(t,"radius",[1,1]);n=n.abs();let r=new l(n.x,-n.y),s=[e.plus(n),e.plus(r),e.minus(n),e.minus(r)];return c(s)};t.exports={circle:function(t){let e=o(t=t||{},"center",[0,0]),n=r(t,"radius",1),a=s(t,"resolution",i),u=[];for(let t=0;t<a;t++){let o=2*Math.PI*t/a,r=l.fromAngleRadians(o).times(n).plus(e);u.push(r)}return c(u)},ellipse:function(t){let e=o(t=t||{},"center",[0,0]),n=o(t,"radius",[1,1]);n=n.abs();let r=s(t,"resolution",i),l=new a([[e.x,e.y+n.y]]);return l=l.appendArc([e.x,e.y-n.y],{xradius:n.x,yradius:n.y,xaxisrotation:0,resolution:r,clockwise:!0,large:!1}),l=l.appendArc([e.x,e.y+n.y],{xradius:n.x,yradius:n.y,xaxisrotation:0,resolution:r,clockwise:!0,large:!1}),l=l.close(),p(l)},rectangle:h,roundedRectangle:function(t){let e,n;if("corner1"in(t=t||{})||"corner2"in t){if("center"in t||"radius"in t)throw new Error("roundedRectangle: should either give a radius and center parameter, or a corner1 and corner2 parameter");let r=o(t,"corner1",[0,0]),s=o(t,"corner2",[1,1]);e=r.plus(s).times(.5),n=s.minus(r).times(.5)}else e=o(t,"center",[0,0]),n=o(t,"radius",[1,1]);n=n.abs();let a=r(t,"roundradius",.2),u=s(t,"resolution",i),c=Math.min(n.x,n.y);c-=.1,a=Math.min(a,c),a=Math.max(0,a),n=new l(n.x-a,n.y-a);let p=h({center:e,radius:n});return a>0&&(p=p.expand(a,u)),p},fromCompactBinary:u}},function(t,e,n){const o=n(12),{cube:r}=n(33);t.exports={toPointCloud:function(t,e){t=t.reTesselated();let n=new o,s={};t.polygons.map((function(t){t.vertices.map((function(t){s[t.getTag()]=t.pos}))}));for(let t in s){let o=s[t],i=r({center:o,radius:e});n=n.unionSub(i,!1,!1)}return n=n.reTesselated(),n}}},function(t,e,n){const{CSG:o}=n(23),{BYBLOCK:r,BYLAYER:s}=n(19),{instantiatePolygon:i,instantiateVector:l}=n(22);function a(t){return new o.Vertex(t)}function u(t){return`new CSG.Vector2D(${t.x},${t.y})`}function c(t){return`${t.x},${t.y},${t.z}`}function p(t){let e="createPolygon([";for(let n of t.vertices)e+=f(n)+",";var n;return e+=`],${function(t){let e="null";if(null!==t&&null!==t.color){let n=t.color;e=`[${n[0]},${n[1]},${n[2]},${n[3]}]`}return e}(t.shared)},${n=t.plane,`[${c(n.normal)},${n.w}]`})`,e}function f(t){return`[${c(t.pos)}]`}function h(t,e,n){let r=t.name,s="";if(t.pptz===t.sptz&0===t.pptz){let e=new o.Vector2D([t.pptx,t.ppty]),n=new o.Vector2D([t.sptx,t.spty]);s=`  let ${r} = CSG.Line2D.fromPoints(${u(e)},${u(n)})\n`}else{let e=new o.Vector3D([t.pptx,t.ppty,t.pptz]),n=new o.Vector3D([t.sptx,t.spty,t.sptz]);s=`  let ${r} = CSG.Line3D.fromPoints(${c(e)},${c(n)})\n`}t.script=s,P(t,e)}function d(t,e,n,r,s,i){if(0===r)t+=`.appendPoint( [${e},${n}] )`;else{let l=new o.Vector2D(s,i),a=new o.Vector2D(e,n),u=r<0,c=!1;t+=`.appendArc([${e},${n}],{radius: ${l.distanceTo(a)*((1+Math.pow(r,2))/(4*r))},xaxisrotation: ${Math.atan(r)/(Math.PI/180)*4},clockwise: ${u},large: ${c},resolution: ${o.defaultResolution2D}})`}return t}function m(t,e,n){const o=parseInt("00000000000000001",2);let r=t.vlen,s=t.pptxs,i=t.pptys,l=t.bulgs,a=t.lflg,u=t.name,c=`  let ${u} = new CSG.Path2D()\n`,p=(a&o)===o;if(r===s.length&&r===i.length&&r===l.length){if(c+=`  ${u} = ${u}`,s.forEach((function(t,e,n){let o=0,r=0,a=0;e>0&&(o=l[e-1],r=s[e-1],a=i[e-1]),c=d(c,s[e],i[e],o,r,a)})),p){let t=l[r-1],e=s[r-1],n=i[r-1];c=d(c,s[0],i[0],t,e,n),c+=`\n  ${u} = ${u}.close()\n  ${u} = CAG.fromPoints(${u}.points)\n`}else c+="\n";t.script=c,P(t,e)}}function g(t,e,n){let r=t.lthk,s=t.pptx,i=t.ppty,l=(t.pptz,t.swid),a=t.ang0,u=t.ang1,c=t.name;if(0===r){let n=`  let ${c} = CSG.Path2D.arc({center: [${s},${i}],radius: ${l},startangle: ${a},endangle: ${u}, resolution: ${o.defaultResolution2D}})\n`;return t.script=n,void P(t,e)}}function y(t,e,n){let r=t.lthk,s=t.pptx,i=t.ppty,l=(t.pptz,t.swid),a=t.name,u=o.defaultResolution2D;if(0===r){let n=`  let ${a} = CAG.circle({center: [${s},${i}],radius: ${l},resolution: ${u}})\n`;return t.script=n,void P(t,e)}let c=`  let ${a} = CAG.circle({center: [${s},${i}],radius: ${l},resolution: ${u}).extrude({offset: [0,0,${r}]})\n`;t.script=c,P(t,e)}function w(t,e,n){let r=t.pptx,s=t.ppty,i=t.pptz,l=t.sptx,a=t.spty,u=t.sptz,c=t.swid,p=t.name,f=o.defaultResolution2D;if(0===i&&0===u){let n=new o.Vector2D(0,0),i=new o.Vector2D(l,a),u=n.distanceTo(i),h=u*c,d=180*Math.atan2(a,l)/Math.PI;d<o.EPS&&(d=0);let m=`  let ${p} = CAG.ellipse({center: [0,0],radius: [${u},${h}],resolution: ${f}}).rotateZ(${d}).translate([${r},${s}])\n`;return t.script=m,void P(t,e)}}function x(t,e,n){let r=t.vlen,s=t.pptxs,i=t.pptys,l=t.pptzs,u=t.flen,c=t.fvals,f=C(_(t,e),n.colorindex);o._CSGDEBUG=!1;let h=[];if(r===s.length&&r===i.length&&r===l.length&&u===c.length){let t=function(t){let e=[],n=0;for(;n<t.length;){let o=t[n++],r=[];for(;o>0;)r.push(t[n++]),o--;e.push(r)}return e}(c),e=function(t,e,n){let o=[],r=0;for(;r<t.length;){let s=t[r],i=e[r],l=n[r];o.push([s,i,l]),r++}return o}(s,i,l),r=0;for(;r<t.length;){let s=t[r],i=[],l=[],u=0;for(;u<s.length;){let t=s[u],n=new o.Vector3D(e[t]);i.push(n);let r=a(n);l.push(r),u++}1===n.dxf.angdir&&(l=l.reverse());let c=new o.Polygon(l,f);h.push(c),r++}}let d=t.name,m=`  const ${d}_polygons = [\n`;for(let t of h)m+="    "+p(t)+",\n";return m+=`  ]\n  let ${d} = CSG.fromPolygons(${d}_polygons)\n`,t.script=m,P(t,e),null}function b(t,e){let n=t.lnam||"0";for(let t of e)if(t.name===n)return t;return null}function v(t){for(let e of t)if("0"===e.name)return e;let e={type:"layer",lnam:"layer0",name:"0",lscl:1,visb:0,spac:0,objects:[]};return t.push(e),e}function P(t,e){let n=b(t,e);null===n&&(n=v(e)),"objects"in n||(n.objects=[]),n.objects.push(t)}function _(t,e){let n=t.cnmb||-1;if(n===s){n=-1;let o=b(t,e);null!==o&&(n=o.cnmb||-1)}return n}function C(t,e){if(t<1)return null;let n=e[(t=function(t,e){let n=t%e;return Math.floor(n>=0?n:n+e)}(t,e.length))-1];return new o.Polygon.Shared.fromColor([n[0]/255,n[1]/255,n[2]/255,n[3]/255])}function S(t){const e=parseInt("00000000000000001",2),n=parseInt("00000000000001000",2),o=parseInt("00000000000010000",2),r=parseInt("00000000000100000",2),s=parseInt("00000000001000000",2);let i=t.lflg,l=null;if((i&n)===n){l={type:"3dline",isclosed:(i&e)===e}}else if((i&o)===o){l={type:"3dpolymesh"},l.fvia=t.fvia,l.fvib=t.fvib;let n=(i&e)===e;l.closedM=n,n=(i&r)===r,l.closedN=n}else if((i&s)===s)l={type:"3dpolyfaces"},l.fvia=t.fvia,l.fvib=t.fvib;else{l={type:"2dline",isclosed:(i&e)===e}}return"cnmb"in t&&(l.cnmb=t.cnmb),"lnam"in t&&(l.lnam=t.lnam),l}function T(t,e,n,r){if(null===t)return null;let s=t.type;if("2dline"===s)return function(t,e,n,o){t.vlen=n.length,t.pptxs=[],t.pptys=[],t.bulgs=[];for(let e of n)t.pptxs.push(e.x),t.pptys.push(e.y),t.bulgs.push(e.bulg);return t.closed?t.lflg=parseInt("00000000000000001",2):t.lflg=0,m(t,e),null}(t,e,n);if("3dline"===s)return null;if("3dpolymesh"===s){let s=t.fvia,i=t.fvib;n.length;n=function(t,e,n,r,s){function i(t,o){return n[(t-1)*e+(o-1)]}let l=[];if(t*e!==n.length)return l;if(t<2|e<2)return l;let u=1;for(;u<t;){let t=1;for(;t<e;){let e=[a(i(u,t)),a(i(u+1,t)),a(i(u+1,t+1)),a(i(u,t+1))];1===s.dxf.angdir&&(e=e.reverse());let n=new o.Polygon(e,r);Number.isFinite(n.plane.w)&&l.push(n),t++}u++}return l}(s,i,n,C(_(t,e),r.colorindex),r)}if("3dpolyfaces"===s&&"fvia"in t){n=function(t,e,n,r,s){let i=[];if(t+e!==n.length)return i;let l=t;for(;l<n.length;){let t=n[l],e=[Math.abs(t.fvia),Math.abs(t.fvib),Math.abs(t.fvic),Math.abs(t.fvid)],u=[];e[0]>0&&(u.push(a(n[e[0]-1])),e[1]>0&&(u.push(a(n[e[1]-1])),e[2]>0&&(u.push(a(n[e[2]-1])),e[3]>0&&u.push(a(n[e[3]-1]))))),u.length>2&&(1===s.dxf.angdir&&(u=u.reverse()),i.push(new o.Polygon(u,r))),l++}return i}(t.fvia,t.fvib,n,C(_(t,e),r.colorindex),r)}let i=t.name,l=`  const ${i}_polygons = [\n`;for(let t of n)l+="    "+p(t)+",\n";return l+=`  ]\n  let ${i} = CSG.fromPolygons(${i}_polygons)\n`,t.script=l,P(t,e),null}function M(t,e){switch(t.name||"Unknown"){case"$ANGDIR":"lflg"in t&&(e.dxf.angdir=t.lflg)}}t.exports=function(t,e){let n=[],r=null,s=[],a=0;v(n);let u=null;for(let c of t.objstack)if(u=null,"type"in c){switch("name"in c?(name=c.name,name=name.replace(/ /g,"_"),name=name.replace(/-/g,"_"),name=name.replace(/\./g,"_"),c.name=name):(c.name="jscad"+a,a+=1),c.type){case"dxf":break;case"layer":r=T(r,n,s,e),s=[],c.objects=[],c.lnam="layer"+n.length,n.push(c);break;case"variable":r=T(r,n,s,e),s=[],M(c,e);break;case"3dface":u=i(c,n,e),null===r&&(r={type:"3dfaces"},r.name="jscad"+a,a+=1);break;case"mesh":r=T(r,n,s,e),s=[],x(c,n,e);break;case"arc":r=T(r,n,s,e),s=[],g(c,n);break;case"circle":r=T(r,n,s,e),y(c,n),s=[];break;case"ellipse":r=T(r,n,s,e),s=[],w(c,n);break;case"line":r=T(r,n,s,e),s=[],h(c,n);break;case"polyline":null===r&&(r=S(c),r.name="jscad"+a,a+=1);break;case"vertex":u=l(c);break;case"seqend":r=T(r,n,s,e),s=[];break;case"lwpolyline":r=T(r,n,s,e),s=[],m(c,n)}u instanceof o.Polygon&&s.push(u),u instanceof o.Vector3D&&s.push(u),u instanceof o.Vector2D&&s.push(u)}r=T(r,n,s,e);let c="function main() {\n  let layers = []\n  return layers.concat(";return n.forEach((function(t){let e=t.lnam||"Unknown";c+=e+"(),"})),c+="[])\n}\n",c+="function createVertex(point) {\n  return new CSG.Vertex(new CSG.Vector3D(point[0],point[1],point[2]))\n}\nfunction createPlane(pointandw) {\n  return new CSG.Plane(new CSG.Vector3D(pointandw[0],pointandw[1],pointandw[2]),pointandw[3])\n}\nfunction createPolygon(listofpoints,color,pointandw) {\n  let vertices = []\n  for (let point of listofpoints) {\n    vertices.push(createVertex(point))\n  }\n  let shared = new CSG.Polygon.Shared(color)\n  let plane = createPlane(pointandw)\n  return new CSG.Polygon(vertices,shared,plane)\n}\n",n.forEach((function(t){c+=function(t){let e=`function ${t.lnam||"Unknown"}() {\n`;for(let n of t.objects)e+=n.script;e+="  return [";for(let n of t.objects)e+=n.name+",";return e+="]\n}\n",e}(t)})),c}}]).default}));